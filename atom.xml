<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>林小墨的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-05T03:08:18.088Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>林小墨</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二叉树</title>
    <link href="http://yoursite.com/2020/04/05/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2020/04/05/%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-04-05T01:12:40.000Z</published>
    <updated>2020-04-05T03:08:18.088Z</updated>
    
    <content type="html"><![CDATA[<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>树 是一种经常用到的数据结构，用来模拟具有树状结构性质的数据集合。</p><p>树里的每一个节点有一个根植和一个包含所有子节点的列表。从图的观点来看，树也可视为一个拥有<code>N 个节点</code>和N-1 条边的一个有向无环图。</p><p>二叉树是一种更为典型的树树状结构。如它名字所描述的那样，二叉树是每个节点最多有<code>两个子树</code>的树结构，通常子树被称作“左子树”和“右子树”。</p><h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><p>二叉树的遍历是指从二叉树的根结点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问一次，且仅被访问一次。<br>二叉树的访问次序可以分为四种：</p><ul><li>前序遍历</li><li>中序遍历</li><li>后序遍历</li><li>层次遍历</li></ul><h4 id="二叉树的前序遍历-力扣144"><a href="#二叉树的前序遍历-力扣144" class="headerlink" title="二叉树的前序遍历/力扣144"></a><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">二叉树的前序遍历</a>/力扣144</h4><p>给定一个二叉树，返回它的 前序 遍历。</p><p> 示例:</p><p>输入: [1,null,2,3]<br>   1<br>    <br>     2<br>    /<br>   3 </p><p>输出: [1,2,3]</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据结构</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>前序遍历首先访问根节点，然后遍历左子树，最后遍历右子树。</p><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><p>深度优先搜索（DFS）</p><p>在这个策略中，我们采用深度作为优先级，以便从跟开始一直到达某个确定的叶子，然后再返回根到达另一个分支。深度优先搜索策略又可以根据根节点、</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">res = []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">dfs(root)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, root.Val)</span><br><span class="line">dfs(root.Left)</span><br><span class="line">dfs(root.Right)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="迭代（stack）"><a href="#迭代（stack）" class="headerlink" title="迭代（stack）"></a>迭代（stack）</h5><p>广度优先搜索（<code>BFS</code>）</p><p>我们按照高度顺序一层一层的访问整棵树，高层次的节点将会比低层次的节点先被访问到。<br>从根节点开始，每次迭代弹出当前栈顶元素，并将其孩子节点压入栈中，先压右孩子再压左孩子。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    res:=[]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root ==<span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    stack:=[]*TreeNode&#123;&#125;<span class="comment">//定义一个栈存储节点信息</span></span><br><span class="line">    <span class="keyword">for</span> root!=<span class="literal">nil</span> || <span class="built_in">len</span>(stack)!=<span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> root!=<span class="literal">nil</span>&#123;</span><br><span class="line">            res=<span class="built_in">append</span>(res,root.Val)</span><br><span class="line">            stack=<span class="built_in">append</span>(stack,root)</span><br><span class="line">            root=root.Left</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root=stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">            stack=stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">            root=root.Right</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树的中序遍历-力扣94"><a href="#二叉树的中序遍历-力扣94" class="headerlink" title="二叉树的中序遍历/力扣94"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">二叉树的中序遍历</a>/力扣94</h4><p>给定一个二叉树，返回它的中序 遍历。</p><p>示例:</p><p>输入: [1,null,2,3]<br>   1<br>    <br>     2<br>    /<br>   3</p><p>输出: [1,3,2]</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据结构</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>中序遍历是先遍历左子树，然后访问根节点，然后遍历右子树。</p><h5 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var res []int</span><br><span class="line"></span><br><span class="line">func inorderTraversal(root *TreeNode) []int &#123;</span><br><span class="line">res &#x3D; []int&#123;&#125;</span><br><span class="line">dfs(root)</span><br><span class="line">return res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func dfs(root *TreeNode) &#123;</span><br><span class="line">if root !&#x3D; nil &#123;</span><br><span class="line">dfs(root.Left)</span><br><span class="line">res &#x3D; append(res, root.Val)</span><br><span class="line">dfs(root.Right)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    res:=[]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root==<span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    stack:=[]*TreeNode&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> root!=<span class="literal">nil</span> || <span class="built_in">len</span>(stack)!=<span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> root!=<span class="literal">nil</span>&#123;</span><br><span class="line">            stack=<span class="built_in">append</span>(stack,root)</span><br><span class="line">            root=root.Left</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root=stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">            res=<span class="built_in">append</span>(res,root.Val)</span><br><span class="line">            stack=stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">            root=root.Right</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树的后序遍历-力扣145"><a href="#二叉树的后序遍历-力扣145" class="headerlink" title="二叉树的后序遍历/力扣145"></a><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">二叉树的后序遍历</a>/力扣145</h4><p>给定一个二叉树，返回它的 后序 遍历。</p><p>示例:</p><p>输入: [1,null,2,3]<br>   1<br>    <br>     2<br>    /<br>   3 </p><p>输出: [3,2,1]</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>后序遍历是先遍历左子树，然后遍历右子树，最后访问树的根节点。</p><h5 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h5><p>基本思路同先序遍历</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">res = []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">dfs(root)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">dfs(root.Left)</span><br><span class="line">dfs(root.Right)</span><br><span class="line">res = <span class="built_in">append</span>(res, root.Val)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h5><p>这里要增加一个辅助节点来节点上一次放入结果数组的值，当一个节点左右都是空的时候，就可以放入结果集，当上一个放入结果集的节点是他的孩子节点的时候，说明他的孩子已经访问完成了，到这里就是第三次了就可以放入了，还有一点要注意的是，当一个节点的左右不为空时，要先加入右孩子，再加入左孩子，这样才能先访问左孩子。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    res:=[]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root==<span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    stack:=[]*TreeNode&#123;&#125;</span><br><span class="line">    pre:= &amp;TreeNode&#123;&#125;</span><br><span class="line">    stack=<span class="built_in">append</span>(stack,root)</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(stack)!=<span class="number">0</span> &#123;</span><br><span class="line">        cur:=stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> (cur.Left==<span class="literal">nil</span> &amp;&amp; cur.Right==<span class="literal">nil</span>) || (pre!=<span class="literal">nil</span> &amp;&amp;(pre==cur.Left || pre==cur.Right))&#123;</span><br><span class="line">            res=<span class="built_in">append</span>(res,cur.Val)</span><br><span class="line">            pre=cur</span><br><span class="line">            stack=stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> cur.Right!=<span class="literal">nil</span>&#123;</span><br><span class="line">                stack=<span class="built_in">append</span>(stack,cur.Right)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> cur.Left!=<span class="literal">nil</span>&#123;</span><br><span class="line">                stack=<span class="built_in">append</span>(stack,cur.Left)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树的层序遍历-力扣102"><a href="#二叉树的层序遍历-力扣102" class="headerlink" title="二叉树的层序遍历/力扣102"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">二叉树的层序遍历</a>/力扣102</h4><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><p>示例：<br>二叉树：[3,9,20,null,null,15,7],</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回其层次遍历结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>层序遍历就是逐层遍历树结构。</p><h5 id="递归-3"><a href="#递归-3" class="headerlink" title="递归"></a>递归</h5><p>深度优先搜索（DFS）</p><p>深度优先遍历，使用一个标记来记录树的深度，按照深度存放到相应的数组里</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result [][]<span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    result = <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    dfsHelper(root, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfsHelper</span><span class="params">(node *TreeNode, level <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(result) &lt; level + <span class="number">1</span> &#123;</span><br><span class="line">        result = <span class="built_in">append</span>(result, <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    result[level] = <span class="built_in">append</span>(result[level], node.Val)</span><br><span class="line">    dfsHelper(node.Left, level + <span class="number">1</span>)</span><br><span class="line">    dfsHelper(node.Right, level + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="迭代-2"><a href="#迭代-2" class="headerlink" title="迭代"></a>迭代</h5><p>广度优先搜索（<code>BFS</code>）</p><p>将树的每一层放入到栈中，记录此层栈的长度，遍历，并将左右子节点存放入栈中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    res:=[][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root==<span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    queue:=[]*TreeNode&#123;&#125;</span><br><span class="line">    queue=<span class="built_in">append</span>(queue,root)</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue)&gt;<span class="number">0</span>&#123;</span><br><span class="line">        counter:=<span class="built_in">len</span>(queue)</span><br><span class="line">        nums:=[]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> <span class="number">0</span>&lt;counter&#123;</span><br><span class="line">            counter--</span><br><span class="line">            <span class="keyword">if</span> queue[<span class="number">0</span>].Left!=<span class="literal">nil</span>&#123;</span><br><span class="line">                queue=<span class="built_in">append</span>(queue,queue[<span class="number">0</span>].Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> queue[<span class="number">0</span>].Right!=<span class="literal">nil</span>&#123;</span><br><span class="line">                queue=<span class="built_in">append</span>(queue,queue[<span class="number">0</span>].Right)</span><br><span class="line">            &#125;</span><br><span class="line">            nums=<span class="built_in">append</span>(nums,queue[<span class="number">0</span>].Val)</span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line">        &#125;</span><br><span class="line">        res=<span class="built_in">append</span>(res,nums)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运用递归解决问题"><a href="#运用递归解决问题" class="headerlink" title="运用递归解决问题"></a>运用递归解决问题</h3><p>我们知道，树可以以递归的方式定义为一个节点（根节点），它包括一个值和一个指向其他节点指针的列表。 递归是树的特性之一。 因此，许多树问题可以通过递归的方式来解决。 对于每个递归层级，我们只能关注单个节点内的问题，并通过递归调用函数来解决其子节点问题。</p><p>通常，我们可以通过 “自顶向下” 或 “自底向上” 的递归来解决树问题。</p><h4 id="自顶向下"><a href="#自顶向下" class="headerlink" title="自顶向下"></a>自顶向下</h4><p>“自顶向下” 意味着在每个递归层级，我们将首先访问节点来计算一些值，并在递归调用函数时将这些值传递到子节点。 所以 “自顶向下” 的解决方案可以被认为是一种<strong>前序遍历</strong>。 </p><p>例如，思考这样一个问题：给定一个二叉树，请寻找它的最大深度。</p><h4 id="自底向上"><a href="#自底向上" class="headerlink" title="自底向上"></a>自底向上</h4><p>“自底向上” 是另一种递归方法。 在每个递归层次上，我们首先对所有子节点递归地调用函数，然后根据返回值和根节点本身的值得到答案。 这个过程可以看作是<strong>后序遍历</strong>的一种。 </p><p>让我们继续讨论前面关于树的最大深度的问题，但是使用不同的思维方式：对于树的单个节点，以节点自身为根的子树的最大深度<code>x</code>是多少？</p><p>如果我们知道一个根节点，以其<strong>左子节</strong>点为根的最大深度为<code>l</code>和以其<strong>右子节</strong>点为根的最大深度为<code>r</code>，我们是否可以回答前面的问题？ 当然可以，我们可以选择它们之间的最大值，再加上1来获得根节点所在的子树的最大深度。 那就是 <code>x = max（l，r）+ 1</code>。</p><p>这意味着对于每一个节点来说，我们都可以在解决它子节点的问题之后得到答案。 因此，我们可以使用“自底向上“的方法。</p><h4 id="二叉树的最大深度-力扣104"><a href="#二叉树的最大深度-力扣104" class="headerlink" title="二叉树的最大深度/力扣104"></a><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">二叉树的最大深度</a>/力扣104</h4><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回它的最大深度 3 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>自顶向下（先序遍历）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    leftMax := maxDepth(root.Left) + <span class="number">1</span></span><br><span class="line">    rightMax := maxDepth(root.Right) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> leftMax &gt;= rightMax &#123;</span><br><span class="line">        <span class="keyword">return</span> leftMax</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rightMax</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">迭代</span></span><br><span class="line"><span class="comment">func maxDepth(root *TreeNode) int &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">if root == nil &#123;</span></span><br><span class="line"><span class="comment">return 0</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">dep := 0</span></span><br><span class="line"><span class="comment">q := make([]*TreeNode, 0)</span></span><br><span class="line"><span class="comment">q = append(q, root)</span></span><br><span class="line"><span class="comment">length := len(q)</span></span><br><span class="line"><span class="comment">for length &gt; 0 &#123;</span></span><br><span class="line"><span class="comment">dep++</span></span><br><span class="line"><span class="comment">for i := 0; i &lt; length; i++ &#123;</span></span><br><span class="line"><span class="comment">node := q[0]</span></span><br><span class="line"><span class="comment">q = q[1:]</span></span><br><span class="line"><span class="comment">if node.Left != nil &#123;</span></span><br><span class="line"><span class="comment">q = append(q, node.Left)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">if node.Right != nil &#123;</span></span><br><span class="line"><span class="comment">q = append(q, node.Right)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">length = len(q)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">return dep</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="对称二叉树-力扣101"><a href="#对称二叉树-力扣101" class="headerlink" title="对称二叉树/力扣101"></a><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">对称二叉树</a>/力扣101</h4><p>难度简单699</p><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure><p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h5 id="递归-4"><a href="#递归-4" class="headerlink" title="递归"></a>递归</h5><p>如果一个树的左子树与右子树镜像对称，那么这个树是对称的。</p><p>如果同时满足下面的条件，两个树互为镜像：</p><ol><li>它们的两个根结点具有相同的值。</li><li>每个树的右子树都与另一个树的左子树镜像对称</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSymmetric</span><span class="params">(root *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root==<span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    left:=root.Left</span><br><span class="line">    right:=root.Right</span><br><span class="line">    <span class="keyword">return</span> issame(left,right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">issame</span><span class="params">(left,right *TreeNode)</span> <span class="title">bool</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> left==<span class="literal">nil</span> &amp;&amp; right==<span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> left==<span class="literal">nil</span>||right==<span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> left.Val!=right.Val&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> issame(left.Right,right.Left)&amp;&amp;issame(left.Left,right.Right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="路径总和力扣112"><a href="#路径总和力扣112" class="headerlink" title="路径总和力扣112"></a><a href="https://leetcode-cn.com/problems/path-sum/" target="_blank" rel="noopener">路径总和</a>力扣112</h4><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例:<br>给定如下二叉树，以及目标和 sum = 22，</p><pre><code>      5     / \    4   8   /   / \  11  13  4 /  \      \7    2      1</code></pre><p>返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。</p><p>遍历整棵树：如果当前节点不是叶子，对它的所有孩子节点，递归调用 hasPathSum 函数，其中 sum 值减去当前节点的权值；如果当前节点是叶子，检查 sum 值是否为 0，也就是是否找到了给定的目标和</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">深度优先</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasPathSum</span><span class="params">(root *TreeNode, sum <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root==<span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    sum-=root.Val</span><br><span class="line">    <span class="keyword">if</span> root.Left==<span class="literal">nil</span>&amp;&amp;root.Right==<span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum==<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root.Left,sum)||hasPathSum(root.Right,sum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">迭代/广度优先/层次遍历</span></span><br><span class="line"><span class="comment">使用两个栈一个存放节点，一个存放目标和减去父亲（祖宗）节点的差，只要节点栈的val等于数据栈即返回true</span></span><br><span class="line"><span class="comment">缺点，深度优先搜索在除了最坏情况下都比广度优先搜索更快</span></span><br><span class="line"><span class="comment">func hasPathSum(root *TreeNode, sum int) bool &#123;</span></span><br><span class="line"><span class="comment">if root == nil&#123;</span></span><br><span class="line"><span class="comment">return false</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">stack := []*TreeNode&#123;root&#125;</span></span><br><span class="line"><span class="comment">sumStack := []int&#123;sum&#125;</span></span><br><span class="line"><span class="comment">for len(stack) != 0&#123;</span></span><br><span class="line"><span class="comment">node := stack[len(stack)-1]</span></span><br><span class="line"><span class="comment">stack = stack[:len(stack)-1]</span></span><br><span class="line"><span class="comment">sum := sumStack[len(sumStack)-1]</span></span><br><span class="line"><span class="comment">sumStack = sumStack[:len(sumStack)-1]</span></span><br><span class="line"><span class="comment">if node.Left == nil &amp;&amp; node.Right == nil &amp;&amp; sum == node.Val&#123;</span></span><br><span class="line"><span class="comment">return true</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">if node.Right != nil &#123;</span></span><br><span class="line"><span class="comment">stack = append(stack, node.Right)</span></span><br><span class="line"><span class="comment">sumStack = append(sumStack, sum-node.Val)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">if node.Left != nil &#123;</span></span><br><span class="line"><span class="comment">stack = append(stack, node.Left)</span></span><br><span class="line"><span class="comment">sumStack = append(sumStack, sum-node.Val)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">return false</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>了解递归并利用递归解决问题并不容易。</p><p>当遇到树问题时，请先思考一下两个问题：</p><ol><li>你能确定一些参数，从该节点自身解决出发寻找答案吗？</li><li>你可以使用这些参数和节点本身的值来决定什么应该是传递给它子节点的参数吗？</li></ol><p>如果答案都是肯定的，那么请尝试使用 “<code>自顶向下</code>” 的递归来解决此问题。</p><p>或者你可以这样思考：对于树中的任意一个节点，如果你知道它子节点的答案，你能计算出该节点的答案吗？ 如果答案是肯定的，那么 “<code>自底向上</code>” 的递归可能是一个不错的解决方法。</p><h3 id="树的练习"><a href="#树的练习" class="headerlink" title="树的练习"></a>树的练习</h3><h4 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">105. 从前序与中序遍历序列构造二叉树</a></h4><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p><p>注意:<br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><p>前序遍历 preorder = [3,9,20,15,7]<br>中序遍历 inorder = [9,3,15,20,7]<br>返回如下的二叉树：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>思路：</p><ul><li>前序遍历：遍历顺序为 父节点 -&gt; 左子节点 -&gt; 右子节点</li><li>后续遍历：遍历顺序为 左子节点 -&gt; 父节点 -&gt; 右子节点</li></ul><p>前序 3为跟，因此中序9 —- 3  —-15 20 7，9为左子树，15 20 7 为右子树</p><p>左子树访问完，前序轮到20 那么 中序   15 —–20——7 ，15为20的左子树，7为20的右子树</p><p>所以构建二叉树的问题本质上就是：</p><ol><li>找到各个子树的根节点 <code>root</code></li><li>构建该根节点的左子树</li><li>构建该根节点的右子树</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(preorder []<span class="keyword">int</span>, inorder []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(preorder)==<span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    val,i:=preorder[<span class="number">0</span>],<span class="number">0</span></span><br><span class="line">    node:= &amp;TreeNode&#123;Val:val&#125;</span><br><span class="line">    <span class="keyword">for</span> inorder[i]!=val&#123;</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    node.Left=buildTree(preorder[<span class="number">1</span>:i+<span class="number">1</span>],inorder[:i])</span><br><span class="line">    node.Right=buildTree(preorder[i+<span class="number">1</span>:],inorder[i+<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">106. 从中序与后序遍历序列构造二叉树</a></h4><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p><p>注意:<br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><p>中序遍历 inorder = [9,3,15,20,7]<br>后序遍历 postorder = [9,15,7,20,3]<br>返回如下的二叉树：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">3</span></span><br><span class="line">  / \</span><br><span class="line"> <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">   /  \</span><br><span class="line">  <span class="number">15</span>   <span class="number">7</span></span><br><span class="line">  </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">* type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment">*     Val int</span></span><br><span class="line"><span class="comment">*     Left *TreeNode</span></span><br><span class="line"><span class="comment">*     Right *TreeNode</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>思路同先序和中序构造二叉树</p><p>不同点：后续数组每次是除去最后面一位（root）和前面n位（left）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(inorder []<span class="keyword">int</span>, postorder []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    l:=<span class="built_in">len</span>(postorder)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> k:=<span class="keyword">range</span> inorder&#123;</span><br><span class="line">        <span class="keyword">if</span> inorder[k]==postorder[l]&#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;TreeNode&#123;</span><br><span class="line">                Val:   inorder[k],</span><br><span class="line">                Left:  buildTree(inorder[:k],postorder[:k]),</span><br><span class="line">                Right: buildTree(inorder[k+<span class="number">1</span>:],postorder[k:l]),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener">116. 填充每个节点的下一个右侧节点指针</a></h4><p>给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p><p>示例：</p><p><img src="https://www.lxmcloud.cn/images/blog/leetcode/lc116_0.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：&#123;&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:4&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:5&#125;,&quot;val&quot;:2&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:6&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;7&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7&#125;,&quot;val&quot;:3&#125;,&quot;val&quot;:1&#125;</span><br><span class="line"></span><br><span class="line">输出：&#123;&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:null,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7&#125;,&quot;right&quot;:null,&quot;val&quot;:6&#125;,&quot;right&quot;:null,&quot;val&quot;:5&#125;,&quot;right&quot;:null,&quot;val&quot;:4&#125;,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;7&quot;,&quot;left&quot;:&#123;&quot;$ref&quot;:&quot;5&quot;&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;6&quot;&#125;,&quot;val&quot;:3&#125;,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;4&quot;&#125;,&quot;val&quot;:2&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;7&quot;&#125;,&quot;val&quot;:1&#125;</span><br></pre></td></tr></table></figure><p>解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。</p><p>提示：</p><p>你只能使用常量级额外空间。<br>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</p><h5 id="递归-dfs："><a href="#递归-dfs：" class="headerlink" title="递归/dfs："></a>递归/dfs：</h5><p>使用next指针 ，左子树找右子树root.Left.Next = root.Right</p><p>右子树找父亲的兄弟的左子树root.Right.Next = root.Next.Left</p><p>从根节点开始，由于第 0 层只有这一个节点，所以不需要连接。直接为第 1 层节点建立 next 指针即可。该算法中需要注意的一点是，当我们为第 N 层节点建立 next 指针时，处于第 N-1N−1 层。当第 NN 层节点的 next 指针全部建立完成后，移至第 NN 层，建立第 N+1N+1 层节点的 next 指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connect</span><span class="params">(root *Node)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> || root.Left == <span class="literal">nil</span> || root.Right == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">root.Left.Next = root.Right</span><br><span class="line"><span class="keyword">if</span> root.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">root.Right.Next = root.Next.Left</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">connect(root.Left)</span><br><span class="line">connect(root.Right)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="层次遍历-bfs"><a href="#层次遍历-bfs" class="headerlink" title="层次遍历/bfs"></a>层次遍历/bfs</h5><p>使用一个栈存放每一层的数，只要不是最后一棵树，那么next指向下一个</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connect</span><span class="params">(root *Node)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root==<span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    node := []*Node&#123;root&#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(node)!=<span class="number">0</span>&#123;</span><br><span class="line">        l:=<span class="built_in">len</span>(node)</span><br><span class="line">        <span class="keyword">for</span> l&gt;<span class="number">0</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> l&gt;<span class="number">1</span>&#123;</span><br><span class="line">                node[<span class="number">0</span>].Next=node[<span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node[<span class="number">0</span>].Left!=<span class="literal">nil</span>&#123;</span><br><span class="line">                node=<span class="built_in">append</span>(node,node[<span class="number">0</span>].Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node[<span class="number">0</span>].Right!=<span class="literal">nil</span>&#123;</span><br><span class="line">                node=<span class="built_in">append</span>(node,node[<span class="number">0</span>].Right)</span><br><span class="line">            &#125;</span><br><span class="line">            l--</span><br><span class="line">            node=node[<span class="number">1</span>:]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="117-填充每个节点的下一个右侧节点指针-II"><a href="#117-填充每个节点的下一个右侧节点指针-II" class="headerlink" title="117. 填充每个节点的下一个右侧节点指针 II"></a><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/" target="_blank" rel="noopener">117. 填充每个节点的下一个右侧节点指针 II</a></h4><p>给定一个二叉树</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p><p>进阶：</p><p>你只能使用常量级额外空间。<br>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</p><p>示例：</p><p><img src="https://www.lxmcloud.cn/images/blog/leetcode/lc117_0.jpg" alt=""></p><p>输入：root = [1,2,3,4,5,null,7]<br>输出：[1,#,2,3,#,4,5,7,#]<br>解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line"></span><br><span class="line">树中的节点数小于 6000</span><br><span class="line">-100 &lt;&#x3D; node.val &lt;&#x3D; 100</span><br></pre></td></tr></table></figure><h5 id="递归："><a href="#递归：" class="headerlink" title="递归："></a>递归：</h5><p>思路同一题上递归</p><p>不同点：对于左子树来说如果没有兄弟，那么next指向父亲的兄弟的左右节点第一个不为空的子树</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">递归</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connect</span><span class="params">(root *Node)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> || (root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> root.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">root.Left.Next = root.Right</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> lastNode = root.Right</span><br><span class="line"><span class="keyword">if</span> lastNode == <span class="literal">nil</span> &#123;</span><br><span class="line">lastNode = root.Left</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> nextNode = root.Next</span><br><span class="line">    <span class="comment">//找到父亲的兄弟的左右节点第一个不为空的子树</span></span><br><span class="line"><span class="keyword">for</span> nextNode != <span class="literal">nil</span> &amp;&amp; (nextNode.Left == <span class="literal">nil</span> &amp;&amp; nextNode.Right == <span class="literal">nil</span>) &#123;</span><br><span class="line">nextNode = nextNode.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> nextNode != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> nextNode.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">lastNode.Next = nextNode.Left</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">lastNode.Next = nextNode.Right</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">connect(root.Right)</span><br><span class="line">connect(root.Left)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h5><p>思路同一题上层次遍历</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connect</span><span class="params">(root *Node)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root==<span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    node := []*Node&#123;root&#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(node)!=<span class="number">0</span>&#123;</span><br><span class="line">        l:=<span class="built_in">len</span>(node)</span><br><span class="line">        <span class="keyword">for</span> l&gt;<span class="number">0</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> l&gt;<span class="number">1</span>&#123;</span><br><span class="line">                node[<span class="number">0</span>].Next=node[<span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node[<span class="number">0</span>].Left!=<span class="literal">nil</span>&#123;</span><br><span class="line">                node=<span class="built_in">append</span>(node,node[<span class="number">0</span>].Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node[<span class="number">0</span>].Right!=<span class="literal">nil</span>&#123;</span><br><span class="line">                node=<span class="built_in">append</span>(node,node[<span class="number">0</span>].Right)</span><br><span class="line">            &#125;</span><br><span class="line">            l--</span><br><span class="line">            node=node[<span class="number">1</span>:]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">236. 二叉树的最近公共祖先</a></h4><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p><p><img src="https://www.lxmcloud.cn/images/blog/leetcode/lc236_0.jpg" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: root = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">8</span>,null,null,<span class="number">7</span>,<span class="number">4</span>], p = <span class="number">5</span>, q = <span class="number">1</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 节点 <span class="number">5</span> 和节点 <span class="number">1</span> 的最近公共祖先是节点 <span class="number">3</span>。</span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: root = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">8</span>,null,null,<span class="number">7</span>,<span class="number">4</span>], p = <span class="number">5</span>, q = <span class="number">4</span></span><br><span class="line">输出: <span class="number">5</span></span><br><span class="line">解释: 节点 <span class="number">5</span> 和节点 <span class="number">4</span> 的最近公共祖先是节点 <span class="number">5</span>。因为根据定义最近公共祖先节点可以为节点本身。</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for TreeNode.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *ListNode</span></span><br><span class="line"><span class="comment"> *     Right *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>说明:</p><p><strong>所有节点的值都是唯一的。</strong><br><strong>p、q 为不同节点且均存在于给定的二叉树中。</strong></p><h5 id="递归dfs"><a href="#递归dfs" class="headerlink" title="递归dfs"></a>递归dfs</h5><p>两个节点p,q分为两种情况：p和q在相同子树中，p和q在不同子树中<br>从根节点遍历，递归向左右子树查询节点信息<br>递归终止条件：如果当前节点为空或等于p或q，则返回当前节点</p><p>递归遍历左右子树，如果左右子树查到节点都不为空，则表明p和q分别在左右子树中，因此，当前节点即为最近公共祖先；<br>如果左右子树其中一个不为空，则返回非空节点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowestCommonAncestor</span><span class="params">(root, p, q *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root ==<span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root==p&#123;</span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root==q&#123;</span><br><span class="line">        <span class="keyword">return</span> q</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找左右两边</span></span><br><span class="line">    left,right:=lowestCommonAncestor(root.Left,p,q),lowestCommonAncestor(root.Right,p,q)</span><br><span class="line">    <span class="keyword">if</span> left==<span class="literal">nil</span>&#123;<span class="comment">//左边找不到</span></span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> right==<span class="literal">nil</span>&#123;<span class="comment">//右边找不到</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root<span class="comment">//如果两边个找到一个，那么最后的一个root就是最近公共祖先</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="297-二叉树的序列化与反序列化"><a href="#297-二叉树的序列化与反序列化" class="headerlink" title="297. 二叉树的序列化与反序列化"></a><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">297. 二叉树的序列化与反序列化</a></h4><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p><p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p>示例: </p><p>你可以将以下二叉树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  4   5</span><br></pre></td></tr></table></figure><p>序列化为 “[1,2,3,null,null,4,5]”<br>提示: 这与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p><p>说明: 不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。</p><p>思路：</p><p>广度优先遍历，使用栈存储</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Codec <span class="keyword">struct</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">Codec</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Codec&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Serializes a tree to a single string.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Codec)</span> <span class="title">serialize</span><span class="params">(root *TreeNode)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root==<span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> res strings.Builder</span><br><span class="line">    stack:=[]*TreeNode&#123;root&#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(stack)!=<span class="number">0</span>&#123;</span><br><span class="line">        node :=stack[<span class="number">0</span>]</span><br><span class="line">        stack=stack[<span class="number">1</span>:]</span><br><span class="line">        <span class="comment">//左右子树入队</span></span><br><span class="line">        <span class="keyword">if</span> node ==<span class="literal">nil</span>&#123;</span><br><span class="line">            res.WriteString(<span class="string">"# "</span>) </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.WriteString(strconv.Itoa(node.Val) + <span class="string">" "</span>)</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, node.Left)</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, node.Right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Deserializes your encoded data to tree.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Codec)</span> <span class="title">deserialize</span><span class="params">(data <span class="keyword">string</span>)</span> *<span class="title">TreeNode</span></span> &#123;    </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data)==<span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    values := strings.Split(data, <span class="string">" "</span>)</span><br><span class="line">    <span class="comment">// pop 第一个元素建立root</span></span><br><span class="line">    v, _ := strconv.Atoi(values[<span class="number">0</span>])</span><br><span class="line">values = values[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">root := &amp;TreeNode&#123;Val: v&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Q []*TreeNode</span><br><span class="line">    Q = <span class="built_in">append</span>(Q, root)</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(Q) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// pop  tree node</span></span><br><span class="line">p := Q[<span class="number">0</span>]</span><br><span class="line">Q = Q[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个元素为左子树</span></span><br><span class="line"><span class="keyword">if</span> values[<span class="number">0</span>] != <span class="string">"#"</span> &#123;</span><br><span class="line">l, _ := strconv.Atoi(values[<span class="number">0</span>])</span><br><span class="line">p.Left = &amp;TreeNode&#123;Val: l&#125;</span><br><span class="line">Q = <span class="built_in">append</span>(Q, p.Left)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为空的情况可以省略，模式指针就是nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个元素为右子树</span></span><br><span class="line"><span class="keyword">if</span> values[<span class="number">1</span>] != <span class="string">"#"</span> &#123;</span><br><span class="line">r, _ := strconv.Atoi(values[<span class="number">1</span>])</span><br><span class="line">p.Right = &amp;TreeNode&#123;Val: r&#125;</span><br><span class="line">Q = <span class="built_in">append</span>(Q, p.Right)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// pop出两个元素</span></span><br><span class="line">values = values[<span class="number">2</span>:]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * data := obj.serialize(root);</span></span><br><span class="line"><span class="comment"> * ans := obj.deserialize(data);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><strong>题目来源</strong>：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;树&quot;&gt;&lt;a href=&quot;#树&quot; class=&quot;headerlink&quot; title=&quot;树&quot;&gt;&lt;/a&gt;树&lt;/h2&gt;&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;树 是一种经常
      
    
    </summary>
    
    
      <category term="力扣" scheme="http://yoursite.com/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="力扣" scheme="http://yoursite.com/tags/%E5%8A%9B%E6%89%A3/"/>
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>go笔记2</title>
    <link href="http://yoursite.com/2020/03/22/go%E7%AC%94%E8%AE%B02/"/>
    <id>http://yoursite.com/2020/03/22/go%E7%AC%94%E8%AE%B02/</id>
    <published>2020-03-22T05:38:41.000Z</published>
    <updated>2020-03-22T13:25:31.119Z</updated>
    
    <content type="html"><![CDATA[<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>Galang也支持面向对象编程(OOP),但是和传统的面向对象编程有区别,并不是纯粹的面向对象语言.所以我们说 Galang支持面向对象编程特性是比较准确的</p><p>Golan没有类(class),go语言的结构体( struct)和其它编程语言的类(class)有同等的地位,你可以理解 Golang是基于 struct来实现OOP特性的.</p><p>Golan面向对象编程非常简洁,去掉了传统OOP语言的继承、方法重载、构造函数和析构函数、隐藏的this指针等等</p><p>Golan仍然有面向对象编程的继承,封装和多态的特性,只是实现的方式和其它OOP语言不一样,比如继承: Galang没有 extends关键字,继承是通过置名字段来实现.</p><p>Golang面向对象(OOP)很优雅,OOP本身就是语言类型系统( type system)的部分,通过接囗 interface关联,耦合性低,也非常灵活.</p><h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="keyword">var</span> person Perosn</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="keyword">var</span> perosn Person = Person&#123;&#125;</span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="keyword">var</span> perosn *Person = <span class="built_in">new</span>(Person)</span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"><span class="keyword">var</span> person *Person = &amp;Perosn&#123;&#125;</span><br></pre></td></tr></table></figure><p>说明：第3种和第4种方式返回的是结构体指针.</p><h5 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一二种声明</span></span><br><span class="line"><span class="keyword">var</span> person Perosn</span><br><span class="line">person.name = <span class="string">"tom"</span></span><br><span class="line">person.age = <span class="number">16</span></span><br><span class="line"><span class="comment">//第三四种声明</span></span><br><span class="line">(*person).name =<span class="string">"tom"</span></span><br><span class="line">person.age=<span class="number">16</span></span><br><span class="line"><span class="comment">//结构体指针访问字段的标准方式应该是:(*结构体指针)字段名,比如(*person).name ="tom"</span></span><br><span class="line"><span class="comment">//但go做了一个简化,也支持结构体指针字段名,比如 person.name="tom".更加符合程序员使用的习惯,go编译器底层对 //person.name做了转化(*person).name</span></span><br></pre></td></tr></table></figure><p>注意：</p><p>如果结构体的字段类型是:指针,s1ice,和map的零值都是ni1,即还没有分配空间,如果需要使用这样的字段,需要先make,才能使用.</p><p>不同结构体变量的字段是独立,互不影响,一个结构体变量字段的更改,不影响另外一个,结构体是值类型.</p><h5 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h5><p>1.结构体的所有字段在内存中是连续的<br>2.结构体是用户单独定义的类型,和其它类型进行转换时需要有完全相同的字段(名字、个数和类型)<br>3.结构体进行type重新定义(相当于取别名), Golang认为是新的数据类型,但是相互间可以强转<br>4.struct的每个字段上,可以写上一个tag,该tag可以通过反射机制获取,常见的使用场景就是序列号和反序列化.<br>[举例说明]</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123;</span><br><span class="line">Name <span class="keyword">string</span> <span class="string">`json : name`</span></span><br><span class="line">    Age <span class="keyword">int</span> <span class="string">`json : age`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[举例说明</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><h5 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>在某些情况下,我们要需要声明(定义方法.比如 Person结构体除了有一些字段外(年龄,姓名 Person结构体还有一些行为比如:可以说话、跑步.通过学习,还可以做算术题.这时就要用方法才能完成</p><p>Golang中的方法是作用在指定的数据类型上的即:和指定的数据类型绑定),因此自定义类型,都可以有方法,而不仅仅是 struct</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(person Person)</span><span class="title">Skill</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"赚钱"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Skill()f方法和Perosn类型绑定</p><p>Skill方法只能通过 Person类型的变量来调用,而不能直接调用,也不能使用其它类型变量来调用</p><p>func(perosn Person)test0{}-perosn表示哪个 Person变量调用,这个perosn就是它的副本,这点和函数传参非常相似.</p><h5 id="方法的调用和传参机制原理"><a href="#方法的调用和传参机制原理" class="headerlink" title="方法的调用和传参机制原理"></a>方法的调用和传参机制原理</h5><p>方法的调用和传参机制和函数基本一样,不一样的地方是方法调用时,会将调用方法的变量,当做实参也传递给方法.下面我们举例说明.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span><span class="title">getSum</span><span class="params">(n1,n2 <span class="keyword">int</span>)</span><span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n1+n2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在内存中的过程</p><p><img src="https://www.lxmcloud.cn/images/blog/gonote/gostructstack.png" alt=""></p><p>说明：</p><p>在通过一个变量去调用方法时,其调用机制和函数一样</p><p>不一样的地方时,变量调用方法时,该变量本身也会作为一个参数传递到方法（如果变量是值类型,则进行值拷贝,如果变量是引用类型,则进行地质拷贝)</p><h5 id="细节注意"><a href="#细节注意" class="headerlink" title="细节注意"></a>细节注意</h5><p>结构体类型是值类型,在方法调用中,遵守值类型的传递机制,是值拷贝传递方式</p><p>如程序员希望在方法中,修改结枃体变量的值,可以通过结构体指针的方式来处理</p><p> Golang的方法作用在指定的数据类型上的(即:和指定的数据类型绑定),因此自定义类型,都可以有方法,而不仅仅是 struct,比如int,foat32等都可以有方法</p><p>方法的访问范围控制的规则,和函数一样.方法名首字母小写,只能在本包访问,方法首字母大写,可以在本包和其它包访问</p><p>如果一个变量实现了 String0这个方法,那么 fmt Println默认会调用这个变量的String()进行输出</p><h5 id="和函数区别"><a href="#和函数区别" class="headerlink" title="和函数区别"></a>和函数区别</h5><p>调用方式不一样<br>函数的调用方式函数名(实参列表<br>方法的调用方式变量方法名(实参列表)</p><p>对于普通函数,接收者为值类型时,不能将指针类型的数据直接传递,反之亦然</p><p>对于方法(如 struct的方法),接收者为值类型时,可以直接用指针类型的变量调用方法,反过来同样也可以</p><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>Golang的结构体没有构造函数,通常可以使用工厂模式来解决这个问题.</p><p>看一个需求<br>一个结构体的声明是这样的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model </span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span>&#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这里的 Student的首字母S是大写的,如果我们想在其它包创建 Student的实例<br>(比如main包),引入 model包后,就可以直接创建 Student结构体的变量(实例)<br>但是问题来了,如果首字母是小写的,比如是 type student struct…}就不不行了,怎么办-&gt;工厂模式来解决</p><p>工厂模式解决mode包的结构体变量首字母小写不能直接引用问题</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model </span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span>&#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStudent</span><span class="params">(n <span class="keyword">string</span>,s <span class="keyword">int</span>)</span> *<span class="title">student</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;student&#123;</span><br><span class="line">        Name :n,</span><br><span class="line">        Age : s,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"./model"</span><span class="comment">//model路径</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span>  <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//student结构体是首字母小写,我们可以通过工厂模式来解决</span></span><br><span class="line">    <span class="keyword">var</span> stu =model.NewStudent(<span class="string">"tom"</span>,<span class="number">16</span>)</span><br><span class="line">    fmt.Println(*stu)<span class="comment">//&amp;&#123;...&#125;</span></span><br><span class="line">    fmt Println (name=<span class="string">", stu.Name,"</span>age=<span class="string">", stu.Age)</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;面向对象&quot;&gt;&lt;a href=&quot;#面向对象&quot; class=&quot;headerlink&quot; title=&quot;面向对象&quot;&gt;&lt;/a&gt;面向对象&lt;/h3&gt;&lt;p&gt;Galang也支持面向对象编程(OOP),但是和传统的面向对象编程有区别,并不是纯粹的面向对象语言.所以我们说 Galang
      
    
    </summary>
    
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>go笔记1</title>
    <link href="http://yoursite.com/2020/03/15/go%E7%AC%94%E8%AE%B01/"/>
    <id>http://yoursite.com/2020/03/15/go%E7%AC%94%E8%AE%B01/</id>
    <published>2020-03-15T03:37:08.000Z</published>
    <updated>2020-03-15T07:09:08.517Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>数组是由相同类型元素的集合组成的数据结构，计算机会为数组分配一块连续的内存来保存其中的元素，我们可以利用数组中元素的索引快速访问元素对应的存储地址。</p><h4 id="数组表示方法"><a href="#数组表示方法" class="headerlink" title="数组表示方法"></a>数组表示方法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line">[<span class="number">200</span>]<span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>与很多语言不同，Go 语言中数组在初始化之后大小就无法改变，存储元素类型相同、但是大小不同的数组类型在 Go 语言看来也是完全不同的，只有两个条件都相同才是同一个类型。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr1 := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">如果不知道数组的长度可以使用...</span><br><span class="line">arr2:=[...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">此时数组长度为元素的个数</span><br></pre></td></tr></table></figure><p>上述两种声明方式在运行期间得到的结果是完全相同的，后一种声明方式在编译期间就会被『转换』成为前一种</p><h4 id="访问和赋值"><a href="#访问和赋值" class="headerlink" title="访问和赋值"></a>访问和赋值</h4><p>数组在内存中其实就是一连串的内存空间，表示数组的方法就是一个指向数组开头的指针、数组中元素的数量以及数组中元素类型占的空间大小</p><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>切片就是动态数组（是数组的引用），它的长度并不固定，我们可以随意向切片中追加元素，而切片会在容量不足时自动扩容。</p><h4 id="切片表示方法"><a href="#切片表示方法" class="headerlink" title="切片表示方法"></a>切片表示方法</h4><p>在 Go 语言中，切片类型的声明方式与数组有一些相似，由于切片的长度是动态的，所以声明时只需要指定切片中的元素类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[]<span class="keyword">int</span></span><br><span class="line">[]<span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>编译期间的切片是 <code>Slice</code> 类型的，但是在运行时切片由如下的 <code>SliceHeader</code> 结构体表示，其中 <code>Data</code> 字段是指向数组的指针，<code>Len</code> 表示当前切片的长度，而 <code>Cap</code> 表示当前切片的容量，也就是 <code>Data</code> 数组的大小：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">Data <span class="keyword">uintptr</span></span><br><span class="line">Len  <span class="keyword">int</span></span><br><span class="line">Cap  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Data</code> 作为一个指针指向的数组是一片连续的内存空间，这片内存空间可以用于存储切片中保存的全部元素，数组中的元素只是逻辑上的概念，底层存储其实都是连续的，所以我们可以将切片理解成一片连续的内存空间加上长度与容量的标识。</p><p><img src="https://img.draveness.me/2019-02-20-golang-slice-struct.png" alt=""></p><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><p>Go 语言中的切片有三种初始化的方式：</p><ol><li>通过下标的方式获得数组或者切片的一部分；</li><li>使用字面量初始化新的切片；</li><li>使用关键字 <code>make</code> 创建切片：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr:=[...]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">slice:=arr[<span class="number">1</span>:]</span><br><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>如果当前的切片不会发生逃逸并且切片非常小的时候，<code>make([]int, 3, 4)</code> 会被直接转换成如下所示的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">4</span>]<span class="keyword">int</span></span><br><span class="line">n := arr[:<span class="number">3</span>]</span><br></pre></td></tr></table></figure><h4 id="追加和覆盖"><a href="#追加和覆盖" class="headerlink" title="追加和覆盖"></a>追加和覆盖</h4><p>内建函数 append将元素追加到切片的末尾,若它有足够的容量,其目标就会重新切片以容纳新的元素.否则,就会分配一个新的基本数组,append返回更新后的切片,因此必须储追加后的结果</p><p>切片 append操作的底层原理分析<br>1)切片 append操作的本质就是对数组扩容<br>2)go底层会创建一下新的数组 newArr安装扩容后大<br>3)将slice原来包含的元素拷贝到新的数组 newArr<br>4)slice重新引用到 newArr<br>5)注意 newArr是在底层来维护的,程序员不可见</p><h4 id="拷贝切片"><a href="#拷贝切片" class="headerlink" title="拷贝切片"></a>拷贝切片</h4><p>两个必须都是切片才可以拷贝,copy是深拷贝这个操作还是会占用非常多的资源，在大切片上执行拷贝操作时一定要注意性能影响。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var slice1 []int &#x3D;[]int&#123;1,2,3,4,5&#125; </span><br><span class="line">var slice2 &#x3D;make([]int, 10)</span><br><span class="line">copy (slice1, slice2)</span><br></pre></td></tr></table></figure><p>浅拷贝:拷贝的是对象的指针,修改内容互相影响<br>深拷贝:整个对象拷贝到另一个内存中,修改内容互不影响</p><h3 id="字符串string"><a href="#字符串string" class="headerlink" title="字符串string"></a>字符串string</h3><p>字符串虽然在 Go 语言中是基本类型 <code>string</code>，但是它实际上是由字符组成的数组，作为数组会占用一片连续的内存空间，这片内存空间存储了的字节共同组成了字符串，Go 语言中的字符串其实是一个只读的字节数组。</p><p>举个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str:&#x3D;&quot;abcd&quot;</span><br></pre></td></tr></table></figure><p>在内存中的存储形式：</p><p><img src="https://www.lxmcloud.cn/images/blog/gonote/gostringmenory.jpg" alt=""></p><p>只读只意味着字符串会分配到只读的内存空间并且这块内存不会被修改，但是在运行时我们其实还是可以将这段内存拷贝到堆或者栈上，将变量的类型转换成 <code>[]byte</code> 之后就可以进行，修改后通过类型转换就可以变回 <code>string</code>，Go 语言只是不支持直接修改 <code>string</code> 类型变量的内存空间。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//细节,我们转成[]byte后,可以处理英文和数字,但是不能处理中文</span></span><br><span class="line"><span class="comment">//原因是[]byte字节来处理,而一个汉字,是3个字节,因此就会出现乱码</span></span><br><span class="line"><span class="comment">//解决方法是将 string转成[]rune即可,因为[]rune是按字符处理,兼容汉字</span></span><br><span class="line">str:=<span class="string">"abc你"</span></span><br><span class="line">arr1:=[]<span class="keyword">rune</span>(str)</span><br><span class="line">arr1[<span class="number">1</span>]=<span class="string">"我"</span></span><br><span class="line">str=<span class="keyword">string</span>(arr1)</span><br></pre></td></tr></table></figure><h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><p>字符串在 Go 语言中的接口其实非常简单，每一个字符串在运行时都会使用如下的 <code>StringHeader</code> 结构体表示，在运行时包的内部其实有一个私有的结构 <code>stringHeader</code>，它有着完全相同的结构只是用于存储数据的 <code>Data</code> 字段使用了 <code>unsafe.Pointer</code> 类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">Data <span class="keyword">uintptr</span></span><br><span class="line">Len  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会经常会说字符串是一个只读的<a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/" target="_blank" rel="noopener">切片</a>类型，这是因为切片在 Go 语言的运行时表示与字符串高度相似，与切片的结构体相比，字符串少了一个表示容量的 <code>Cap</code> 字段，因为字符串作为只读的类型，我们并不会直接向字符串直接追加元素改变其本身的内存空间，所有在字符串上执行的写入操作实际都是通过拷贝实现的。</p><h4 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h4><p>Go 语言拼接字符串会使用 <code>+</code> 符号</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str1:=<span class="string">"abcd"</span></span><br><span class="line">str2:=<span class="string">"efg"</span></span><br><span class="line">str1+=str2</span><br></pre></td></tr></table></figure><p>在正常情况下，运行时会调用 <code>copy</code> 将输入的多个字符串拷贝到目标字符串所在的内存空间中，新的字符串是一片新的内存空间，与原来的字符串也没有任何关联，一旦需要拼接的字符串非常大，拷贝带来的性能损失就是无法忽略的。</p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><h4 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h4><p>哈希表是计算机科学中的最重要数据结构之一，这不仅因为它 <code>O(1)</code> 的读写性能非常优秀，还因为它提供了键值之间的映射。想要实现一个性能优异的哈希表，需要注意两个关键点 —— 哈希函数和冲突解决方法。</p><h5 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h5><p>实现哈希表的关键点在于如何选择哈希函数，哈希函数的选择在很大程度上能够决定哈希表的读写性能，在理想情况下，哈希函数应该能够将不同键能够地映射到不同的索引上，这要求<strong>哈希函数输出范围大于输入范围</strong>，但是由于键的数量会远远大于映射的范围，所以在实际使用时，这个理想的结果是不可能实现的。</p><p>在一个使用结果较为均匀的哈希函数中，哈希的增删改查都需要 <code>O(1)</code> 的时间复杂度，但是非常不均匀的哈希函数会导致所有的操作都会占用最差 <code>O(n)</code> 的复杂度，所以在哈希表中使用好的哈希函数是至关重要的。</p><h5 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h5><p>在通常情况下，哈希函数输入的范围一定会远远大于输出的范围，所以在使用哈希表时一定会遇到冲突，哪怕我们使用了完美的哈希函数，当输入的键足够多最终也会造成冲突。然而我们的哈希函数往往都是不完美的，输出的范围是有限的，所以一定会发生哈希碰撞，这时就需要一些方法来解决哈希碰撞的问题，常见方法的就是开放寻址法和拉链法。</p><h6 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h6><p>开放寻址法是一种在哈希表中解决哈希碰撞的方法，这种方法的核心思想是<strong>对数组中的元素依次探测和比较以判断目标键值对是否存在于哈希表中</strong>，如果我们使用开放寻址法来实现哈希表，那么在支撑哈希表的数据结构就是数组，不过因为数组的长度有限，存储 <code>(author, draven)</code> 这个键值对时会从如下的索引开始遍历：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index := hash(<span class="string">"author"</span>) % array.<span class="built_in">len</span></span><br></pre></td></tr></table></figure><p>当我们向当前哈希表写入新的数据时发生了冲突，就会将键值对写入到下一个不为空的位置：</p><p><img src="https://img.draveness.me/2019-12-30-15777168478785-open-addressing-and-set.png" alt="open-addressing-and-set"></p><p><strong>开放地址法写入数据</strong></p><p>如上图所示，当 Key3 与已经存入哈希表中的两个键值对 Key1 和 Key2 发生冲突时，Key3 会被写入 Key2 后面的空闲内存中；当我们再去读取 Key3 对应的值时就会先对键进行哈希并取模，这会帮助我们找到 Key1，因为 Key1 与我们期望的键 Key3 不匹配，所以会继续查找后面的元素，直到内存为空或者找到目标元素。</p><p><img src="https://img.draveness.me/2019-12-30-15777168478791-open-addressing-and-get.png" alt="open-addressing-and-get"></p><p><strong>开放地址法读取数据</strong></p><p>当需要查找某个键对应的值时，就会从索引的位置开始对数组进行线性探测，找到目标键值对或者空内存就意味着这一次查询操作的结束。</p><p>开放寻址法中对性能影响最大的就是<strong>装载因子</strong>，它是数组中元素的数量与数组大小的比值，随着装载因子的增加，线性探测的平均用时就会逐渐增加，这会同时影响哈希表的读写性能，当装载率超过 70% 之后，哈希表的性能就会急剧下降，而一旦装载率达到 100%，整个哈希表就会完全失效，这时查找任意元素都需要遍历数组中全部的元素，所以在实现哈希表时一定要时刻关注装载因子的变化。</p><h6 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h6><p>与开放地址法相比，拉链法是哈希表中最常见的实现方法，大多数的编程语言都用拉链法实现哈希表，它的实现比较开放地址法稍微复杂一些，但是平均查找的长度也比较短，各个用于存储节点的内存都是动态申请的，可以节省比较多的存储空间。</p><p>实现拉链法一般会使用数组加上链表，不过有一些语言会在拉链法的哈希中引入红黑树以优化性能，拉链法会使用链表数组作为哈希底层的数据结构，我们可以将它看成一个可以扩展的『二维数组』：</p><p><img src="https://img.draveness.me/2019-12-30-15777168478798-separate-chaing-and-set.png" alt="separate-chaing-and-set"></p><p><strong>图 3-10 拉链法写入数据</strong></p><p>如上图所示，当我们需要将一个键值对 <code>(Key6, Value6)</code> 写入哈希表时，键值对中的键 <code>Key6</code> 都会先经过一个哈希函数，哈希函数返回的哈希会帮助我们选择一个桶，和开放地址法一样，选择桶的方式就是直接对哈希返回的结果取模：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index := hash(<span class="string">"Key6"</span>) % array.<span class="built_in">len</span></span><br></pre></td></tr></table></figure><p>选择了 2 号桶之后就可以遍历当前桶中的链表了，在遍历链表的过程中会遇到以下两种情况：</p><ol><li>找到键相同的键值对 —— 更新键对应的值；</li><li>没有找到键相同的键值对 —— 在链表的末尾追加新键值对；</li></ol><p>将键值对写入哈希之后，要通过某个键在其中获取映射的值，就会经历如下的过程：</p><p><img src="https://img.draveness.me/2019-12-30-15777168478804-separate-chaing-and-get.png" alt="separate-chaing-and-get"></p><p><strong>图 3-11 拉链法读取数据</strong></p><p>Key11 展示了一个键在哈希表中不存在的例子，当哈希表发现它命中 4 号桶时，它会依次遍历桶中的链表，然而遍历到链表的末尾也没有找到期望的键，所以哈希表中没有该键对应的值。</p><p>在一个性能比较好的哈希表中，每一个桶中都应该有 0<del>1 个元素，有时会有 2</del>3 个，很少会超过这个数量，计算哈希、定位桶和遍历链表三个过程是哈希表读写操作的主要开销，使用拉链法实现的哈希也有装载因子这一概念：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">装载因子 :&#x3D; 元素数量 &#x2F; 桶数量</span><br></pre></td></tr></table></figure><p>与开放地址法一样，拉链法的装载因子越大，哈希的读写性能就越差，在一般情况下使用拉链法的哈希表装载因子都不会超过 1，当哈希表的装载因子较大时就会触发哈希的扩容，创建更多的桶来存储哈希中的元素，保证性能不会出现严重的下降。如果有 1000 个桶的哈希表存储了 10000 个键值对，它的性能是保存 1000 个键值对的 1/10，但是仍然比在链表中直接读写好 1000 倍。</p><h4 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h4><p>Go 语言运行时同时使用了多个数据结构组合表示哈希表，其中使用 hmap 结构体来表示哈希</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">count     <span class="keyword">int</span></span><br><span class="line">flags     <span class="keyword">uint8</span></span><br><span class="line">B         <span class="keyword">uint8</span></span><br><span class="line">noverflow <span class="keyword">uint16</span></span><br><span class="line">hash0     <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line">buckets    unsafe.Pointer</span><br><span class="line">oldbuckets unsafe.Pointer</span><br><span class="line">nevacuate  <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line">extra *mapextra</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>count</code> 表示当前哈希表中的元素数量；</li><li><code>B</code> 表示当前哈希表持有的 <code>buckets</code> 数量，但是因为哈希表中桶的数量都 2 的倍数，所以该字段会存储对数，也就是 <code>len(buckets) == 2^B</code>；</li><li><code>hash0</code> 是哈希的种子，它能为哈希函数的结果引入随机性，这个值在创建哈希表时确定，并在调用哈希函数时作为参数传入；</li><li><code>oldbuckets</code> 是哈希在扩容时用于保存之前 <code>buckets</code> 的字段，它的大小是当前 <code>buckets</code> 的一半；</li></ol><p><img src="https://img.draveness.me/2019-12-30-15777168478811-hmap-and-buckets.png" alt="hmap-and-buckets"></p><p>如上图所示哈希表 <code>hmap</code> 的桶就是 <code>bmap</code>，每一个 <code>bmap</code> 都能存储 8 个键值对，当哈希表中存储的数据过多，单个桶无法装满时就会使用 <code>extra.overflow</code> 中桶存储溢出的数据。上述两种不同的桶在内存中是连续存储的，我们在这里将它们分别称为正常桶和溢出桶，上图中黄色的 <code>bmap</code> 就是正常桶，绿色的 <code>bmap</code> 是溢出桶，溢出桶是在 Go 语言还使用 C 语言实现时就使用的设计<a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/#fn:3" target="_blank" rel="noopener">3</a>，由于它能够减少扩容的频率所以一直使用至今。</p><p>这个桶的结构体 <code>bmap</code> 在 Go 语言源代码中的定义只包含一个简单的 <code>tophash</code> 字段，<code>tophash</code> 存储了键的哈希的高 8 位，通过比较不同键的哈希的高 8 位可以减少访问键值对次数以提高性能：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">tophash [bucketCnt]<span class="keyword">uint8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>bmap</code> 结构体其实不止包含 <code>tophash</code> 字段，由于哈希表中可能存储不同类型的键值对并且 Go 语言也不支持泛型，所以键值对占据的内存空间大小只能在编译时进行推导，这些字段在运行时也都是通过计算内存地址的方式直接访问的，所以它的定义中就没有包含这些字段，但是我们能根据编译期间的 <a href="https://github.com/golang/go/blob/be64a19d99918c843f8555aad580221207ea35bc/src/cmd/compile/internal/gc/reflect.go#L82-L187" target="_blank" rel="noopener"><code>cmd/compile/internal/gc.bmap</code></a> 函数对它的结构重建：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    topbits  [<span class="number">8</span>]<span class="keyword">uint8</span></span><br><span class="line">    keys     [<span class="number">8</span>]keytype</span><br><span class="line">    values   [<span class="number">8</span>]valuetype</span><br><span class="line">    pad      <span class="keyword">uintptr</span></span><br><span class="line">    overflow <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果哈希表存储的数据逐渐增多，我们会对哈希表进行扩容或者使用额外的桶存储溢出的数据，不会让单个桶中的数据超过 8 个，不过溢出桶只是临时的解决方案，创建过多的溢出桶最终也会导致哈希的扩容。</p><p>从 Go 语言哈希的定义中就可以发现，它比前面两节提到的数组和切片复杂得多，结构体中不仅包含大量字段，还使用了较多的复杂结构，在后面的小节中我们会详细介绍不同字段的作用。</p><h4 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hash := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line"><span class="string">"1"</span>: <span class="number">2</span>,</span><br><span class="line"><span class="string">"3"</span>: <span class="number">4</span>,</span><br><span class="line"><span class="string">"5"</span>: <span class="number">6</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果只是声明的话需要make分配内存后才能使用</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">a=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>,<span class="number">10</span>)</span><br><span class="line"><span class="comment">//也可以合并两步</span></span><br><span class="line">a:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>,<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h4 id="增加和删除"><a href="#增加和删除" class="headerlink" title="增加和删除"></a>增加和删除</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[<span class="string">"key"</span>]=value<span class="comment">//如果key还没有，就是增加，如果有就是修改</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">delete</span><span class="params">(m <span class="keyword">map</span>[Type]Type1,key Type)</span></span></span><br><span class="line"><span class="comment">//内建函数delete按照指定的健值将元素从映射中删除，若m为nil或无此元素，delete不进行操作</span></span><br></pre></td></tr></table></figure><h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><p>map是引用类型,遵守引用类型传递的机制在一个函数接收map,修改后,会直接修改原来的map</p><p>map的容量达到后,再想map增加元素,会自动扩容,并不会发生 panic,也就是说map能动态的增长键值对( key-value)</p><p>map的value也经常使用 struct 类型,更适合管理复杂的数据(比前面value是一个map更好)</p><p>引用：<a href="https://draveness.me/golang/" target="_blank" rel="noopener">https://draveness.me/golang/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h3&gt;&lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h4&gt;&lt;p&gt;数组是
      
    
    </summary>
    
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>力扣-97</title>
    <link href="http://yoursite.com/2020/03/15/%E5%8A%9B%E6%89%A3-97/"/>
    <id>http://yoursite.com/2020/03/15/%E5%8A%9B%E6%89%A3-97/</id>
    <published>2020-03-15T02:52:10.000Z</published>
    <updated>2020-03-15T03:18:45.128Z</updated>
    
    <content type="html"><![CDATA[<h4 id="97-交错字符串"><a href="#97-交错字符串" class="headerlink" title="97. 交错字符串"></a><a href="https://leetcode-cn.com/problems/interleaving-string/" target="_blank" rel="noopener">97. 交错字符串</a></h4><p>难度困难141收藏分享切换为英文关注反馈</p><p>给定三个字符串 <em>s1</em>, <em>s2</em>, <em>s3</em>, 验证 <em>s3</em> 是否是由 <em>s1</em> 和 <em>s2</em> 交错组成的。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s1 &#x3D; &quot;aabcc&quot;, s2 &#x3D; &quot;dbbca&quot;, s3 &#x3D; &quot;aadbbcbcac&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s1 &#x3D; &quot;aabcc&quot;, s2 &#x3D; &quot;dbbca&quot;, s3 &#x3D; &quot;aadbbbaccc&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p>分析：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">首先判断len1+len2 是否等于 len3若等于才有必要继续</span><br><span class="line">使用动态规划dp[][]，长度为s1和s2的长度加一</span><br><span class="line">dp[i][j]表示s1前i个和s2前j个元素目前是否能和成s3前i+j个，</span><br><span class="line">也就是说如果最后dp[<span class="built_in">len</span>(s1)][<span class="built_in">len</span>(s2)]==<span class="literal">true</span>，则可以组成</span><br><span class="line">首先初始化dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="literal">true</span>，第一行和第一列</span><br><span class="line">dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] &amp;&amp; s1[i<span class="number">-1</span>] == s3[i<span class="number">-1</span>]</span><br><span class="line">dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-1</span>] &amp;&amp; s2[j<span class="number">-1</span>] == s3[j<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">假设dp[i][j]为<span class="literal">true</span>,那么只有两种情况</span><br><span class="line">情况一：dp[i<span class="number">-1</span>][j]==<span class="literal">true</span> &amp;&amp; s3[i+j<span class="number">-1</span>] == s1[i<span class="number">-1</span>]</span><br><span class="line">情况二：dp[i][j<span class="number">-1</span>]==<span class="literal">true</span> &amp;&amp; s3[i+j<span class="number">-1</span>] == s2[j<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">时间复杂度：O(m⋅n)；长度为 n 的 dp 数组需要被填充 m 次。</span><br><span class="line">空间复杂度：O(n)；n 是字符串 s1 的长度</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isInterleave</span><span class="params">(s1 <span class="keyword">string</span>, s2 <span class="keyword">string</span>, s3 <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">len1 := <span class="built_in">len</span>(s1)</span><br><span class="line">len2 := <span class="built_in">len</span>(s2)</span><br><span class="line">len3 := <span class="built_in">len</span>(s3)</span><br><span class="line"><span class="keyword">if</span> len1+len2 != len3 &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">dp := <span class="built_in">make</span>([][]<span class="keyword">bool</span>, len1+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= len1; i++ &#123;</span><br><span class="line">dp[i] = <span class="built_in">make</span>([]<span class="keyword">bool</span>, len2+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] &amp;&amp; s1[i<span class="number">-1</span>] == s3[i<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= len2; j++ &#123;</span><br><span class="line">dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-1</span>] &amp;&amp; s2[j<span class="number">-1</span>] == s3[j<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= len1; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= len2; j++ &#123;</span><br><span class="line">dp[i][j] = (dp[i<span class="number">-1</span>][j] &amp;&amp; s3[i+j<span class="number">-1</span>] == s1[i<span class="number">-1</span>]) || (dp[i][j<span class="number">-1</span>] &amp;&amp; s3[i+j<span class="number">-1</span>] == s2[j<span class="number">-1</span>])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[len1][len2]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://www.lxmcloud.cn/images/blog/leetcode/lc97.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;97-交错字符串&quot;&gt;&lt;a href=&quot;#97-交错字符串&quot; class=&quot;headerlink&quot; title=&quot;97. 交错字符串&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/interleaving-string
      
    
    </summary>
    
    
      <category term="力扣" scheme="http://yoursite.com/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="力扣" scheme="http://yoursite.com/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>力扣-16</title>
    <link href="http://yoursite.com/2020/03/15/%E5%8A%9B%E6%89%A3-16/"/>
    <id>http://yoursite.com/2020/03/15/%E5%8A%9B%E6%89%A3-16/</id>
    <published>2020-03-15T02:33:24.000Z</published>
    <updated>2020-03-15T02:51:15.181Z</updated>
    
    <content type="html"><![CDATA[<h4 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a><a href="https://leetcode-cn.com/problems/3sum-closest/" target="_blank" rel="noopener">16. 最接近的三数之和</a></h4><p>难度中等379收藏分享切换为英文关注反馈</p><p>给定一个包括 <em>n</em> 个整数的数组 <code>nums</code> 和 一个目标值 <code>target</code>。找出 <code>nums</code> 中的三个整数，使得它们的和与 <code>target</code> 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例如，给定数组 nums &#x3D; [-1，2，1，-4], 和 target &#x3D; 1.</span><br><span class="line"></span><br><span class="line">与 target 最接近的三个数的和为 2. (-1 + 2 + 1 &#x3D; 2).</span><br></pre></td></tr></table></figure><p>分析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">先排序,然后使用res保存三个数之和，初始res为res &#x3D; nums[0] + nums[1] + nums[2]</span><br><span class="line">使用双指针，对于每一个元素，双指针都从数组两端出发，每次记录sum :&#x3D; nums[i] + nums[L] + nums[R]</span><br><span class="line">如果小于target左指针往右移动，若大于target右指针往左移动,直到左右指针相遇</span><br><span class="line">每次计算sum与target的差值，只要比上一次记录要小就重新记录。</span><br><span class="line"></span><br><span class="line">时间复杂度O(n(logn+n))排序nlogn查找n*n&#x2F;2</span><br><span class="line">空间复杂度O(1)</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSumClosest</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">3</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">sort.Ints(nums)</span><br><span class="line"></span><br><span class="line">res := nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-2</span>; i++ &#123;</span><br><span class="line">L := i + <span class="number">1</span></span><br><span class="line">R := <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> L &gt;= R &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">sum := nums[i] + nums[L] + nums[R]</span><br><span class="line"><span class="keyword">if</span> sum &gt; target &#123;</span><br><span class="line">R--</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> sum &lt; target &#123;</span><br><span class="line">L++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> distanceInt(sum, target) &lt; distanceInt(res, target) &#123;</span><br><span class="line">res = sum</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">distanceInt</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line"><span class="keyword">return</span> b - a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> a - b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://www.lxmcloud.cn/images/blog/leetcode/lc16.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;16-最接近的三数之和&quot;&gt;&lt;a href=&quot;#16-最接近的三数之和&quot; class=&quot;headerlink&quot; title=&quot;16. 最接近的三数之和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/3sum-close
      
    
    </summary>
    
    
      <category term="力扣" scheme="http://yoursite.com/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="力扣" scheme="http://yoursite.com/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>力扣-1184</title>
    <link href="http://yoursite.com/2020/03/15/%E5%8A%9B%E6%89%A3-1184/"/>
    <id>http://yoursite.com/2020/03/15/%E5%8A%9B%E6%89%A3-1184/</id>
    <published>2020-03-15T02:29:34.000Z</published>
    <updated>2020-03-15T02:51:10.353Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1184-公交站间的距离"><a href="#1184-公交站间的距离" class="headerlink" title="1184. 公交站间的距离"></a><a href="https://leetcode-cn.com/problems/distance-between-bus-stops/" target="_blank" rel="noopener">1184. 公交站间的距离</a></h4><p>难度简单16</p><p>环形公交路线上有 <code>n</code> 个站，按次序从 <code>0</code> 到 <code>n - 1</code> 进行编号。我们已知每一对相邻公交站之间的距离，<code>distance[i]</code> 表示编号为 <code>i</code> 的车站和编号为 <code>(i + 1) % n</code> 的车站之间的距离。</p><p>环线上的公交车都可以按顺时针和逆时针的方向行驶。</p><p>返回乘客从出发点 <code>start</code> 到目的地 <code>destination</code> 之间的最短距离。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/08/untitled-diagram-1.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：distance &#x3D; [1,2,3,4], start &#x3D; 0, destination &#x3D; 1</span><br><span class="line">输出：1</span><br><span class="line">解释：公交站 0 和 1 之间的距离是 1 或 9，最小值是 1。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/08/untitled-diagram-1-1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：distance &#x3D; [1,2,3,4], start &#x3D; 0, destination &#x3D; 2</span><br><span class="line">输出：3</span><br><span class="line">解释：公交站 0 和 2 之间的距离是 3 或 7，最小值是 3。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/08/untitled-diagram-1-2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：distance &#x3D; [1,2,3,4], start &#x3D; 0, destination &#x3D; 3</span><br><span class="line">输出：4</span><br><span class="line">解释：公交站 0 和 3 之间的距离是 6 或 4，最小值是 4。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 10^4</code></li><li><code>distance.length == n</code></li><li><code>0 &lt;= start, destination &lt; n</code></li><li><code>0 &lt;= distance[i] &lt;= 10^4</code></li></ul><p>代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">distanceBetweenBusStops</span><span class="params">(distance []<span class="keyword">int</span>, start <span class="keyword">int</span>, destination <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> result <span class="keyword">int</span></span><br><span class="line">i := start</span><br><span class="line">j := destination</span><br><span class="line">result1 := <span class="number">0</span></span><br><span class="line">result2 := <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> i == j &#123;</span><br><span class="line">result = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> i &lt; j &#123;</span><br><span class="line">x := j - i</span><br><span class="line"><span class="keyword">for</span> x &gt; <span class="number">0</span> &#123;</span><br><span class="line">result1 += distance[i]</span><br><span class="line">i++</span><br><span class="line">x--</span><br><span class="line">&#125;</span><br><span class="line">i = start</span><br><span class="line">y := <span class="built_in">len</span>(distance) + i - j</span><br><span class="line"><span class="keyword">for</span> y &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">i = <span class="built_in">len</span>(distance)</span><br><span class="line">&#125;</span><br><span class="line">result2 += distance[i<span class="number">-1</span>]</span><br><span class="line">i--</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">i = <span class="built_in">len</span>(distance)</span><br><span class="line">&#125;</span><br><span class="line">y--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> i &gt; j &#123;</span><br><span class="line">x := <span class="built_in">len</span>(distance) - i + j</span><br><span class="line"><span class="keyword">for</span> x &gt; <span class="number">0</span> &#123;</span><br><span class="line">result1 += distance[i]</span><br><span class="line">i++</span><br><span class="line"><span class="keyword">if</span> i == <span class="built_in">len</span>(distance) &#123;</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">x--</span><br><span class="line">&#125;</span><br><span class="line">i = start</span><br><span class="line">y := i - j</span><br><span class="line"><span class="keyword">for</span> y &gt; <span class="number">0</span> &#123;</span><br><span class="line">result2 += distance[i<span class="number">-1</span>]</span><br><span class="line">i--</span><br><span class="line">y--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> result1 &lt; result2 &#123;</span><br><span class="line">result = result1</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">result = result2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://www.lxmcloud.cn/images/blog/leetcode/lc1184.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1184-公交站间的距离&quot;&gt;&lt;a href=&quot;#1184-公交站间的距离&quot; class=&quot;headerlink&quot; title=&quot;1184. 公交站间的距离&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/distanc
      
    
    </summary>
    
    
      <category term="力扣" scheme="http://yoursite.com/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="力扣" scheme="http://yoursite.com/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>力扣-415</title>
    <link href="http://yoursite.com/2020/03/15/%E5%8A%9B%E6%89%A3-415/"/>
    <id>http://yoursite.com/2020/03/15/%E5%8A%9B%E6%89%A3-415/</id>
    <published>2020-03-15T02:14:56.000Z</published>
    <updated>2020-03-15T02:49:16.600Z</updated>
    
    <content type="html"><![CDATA[<h4 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415. 字符串相加"></a><a href="https://leetcode-cn.com/problems/add-strings/" target="_blank" rel="noopener">415. 字符串相加</a></h4><p>难度简单142</p><p>给定两个字符串形式的非负整数 <code>num1</code> 和<code>num2</code> ，计算它们的和。</p><p><strong>注意：</strong></p><ol><li><code>num1</code> 和<code>num2</code> 的长度都小于 5100.</li><li><code>num1</code> 和<code>num2</code> 都只包含数字 <code>0-9</code>.</li><li><code>num1</code> 和<code>num2</code> 都不包含任何前导零。</li><li><strong>你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。</strong></li></ol><p>分析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">双指针法，从末位开始依次相加，判断是否进位，始终用x表示双指针的和，若大于10则下一轮初始为1（表示进位）</span><br><span class="line">因为每一次计算结果按照顺序存放入result，因此答案需要反转</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addStrings</span><span class="params">(num1 <span class="keyword">string</span>, num2 <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">l1 := <span class="built_in">len</span>(num1) - <span class="number">1</span></span><br><span class="line">l2 := <span class="built_in">len</span>(num2) - <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">byte</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> result = []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> l1 &gt;= <span class="number">0</span> || l2 &gt;= <span class="number">0</span> || x != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> l1 &gt;= <span class="number">0</span> &#123;</span><br><span class="line">x += (num1[l1] - <span class="string">'0'</span>)</span><br><span class="line">l1--</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> l2 &gt;= <span class="number">0</span> &#123;</span><br><span class="line">x += (num2[l2] - <span class="string">'0'</span>)</span><br><span class="line">l2--</span><br><span class="line">&#125;</span><br><span class="line">result = <span class="built_in">append</span>(result, (x%<span class="number">10</span>)+<span class="string">'0'</span>)</span><br><span class="line">x = x / <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(result)<span class="number">-1</span>; i &lt; j; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">result[i], result[j] = result[j], result[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://www.lxmcloud.cn/images/blog/leetcode/lc415.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;415-字符串相加&quot;&gt;&lt;a href=&quot;#415-字符串相加&quot; class=&quot;headerlink&quot; title=&quot;415. 字符串相加&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/add-strings/&quot; ta
      
    
    </summary>
    
    
      <category term="力扣" scheme="http://yoursite.com/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="力扣" scheme="http://yoursite.com/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>力扣-3</title>
    <link href="http://yoursite.com/2020/03/08/%E5%8A%9B%E6%89%A3-3/"/>
    <id>http://yoursite.com/2020/03/08/%E5%8A%9B%E6%89%A3-3/</id>
    <published>2020-03-08T03:25:58.000Z</published>
    <updated>2020-03-15T02:52:28.073Z</updated>
    
    <content type="html"><![CDATA[<h4 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. 无重复字符的最长子串</a></h4><p>难度中等3258收藏分享切换为英文关注反馈</p><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><h4 id="暴力hasmap"><a href="#暴力hasmap" class="headerlink" title="暴力hasmap"></a>暴力hasmap</h4><p>分析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">从头开始遍历,将字符传入map里，只要遇到重复比较长度,我们就把i回溯到相同字符两个中的前一个处</span><br><span class="line">即i &#x3D; i - len(maps) + key</span><br><span class="line">然后从下一个字符开始重复上述操作</span><br><span class="line">时间复杂度:最不利n^26</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> maps <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> length <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> result <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line">maps = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(s); i &lt; j; i++ &#123;</span><br><span class="line">key, ok := maps[<span class="keyword">string</span>(s[i])]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">maps[<span class="keyword">string</span>(s[i])] = length</span><br><span class="line">length++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> result &lt; length &#123;</span><br><span class="line">result = length</span><br><span class="line">&#125;</span><br><span class="line">i = i - <span class="built_in">len</span>(maps) + key</span><br><span class="line">maps = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">length = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> result &lt; length &#123;</span><br><span class="line">result = length</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://www.lxmcloud.cn/images/blog/leetcode/lc3_0.jpg" alt=""></p><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>分析：使用滑动窗口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">窗口可以在两个边界移动一开始窗口大小为0</span><br><span class="line">随着数组下标的前进窗口的右侧依次增大</span><br><span class="line">每次查询窗口里的字符，若窗口中有查询的字符</span><br><span class="line">窗口的左侧移动到该字符加一的位置</span><br><span class="line">每次记录窗口的最大程度</span><br><span class="line">重复操作直到数组遍历完成</span><br><span class="line">返回最大窗口长度即可</span><br><span class="line"></span><br><span class="line">时间复杂度O(n)</span><br><span class="line">空间复杂度O(n)</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> Length <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> s1 <span class="keyword">string</span></span><br><span class="line">left := <span class="number">0</span></span><br><span class="line">right := <span class="number">0</span></span><br><span class="line">s1 = s[left:right]</span><br><span class="line"><span class="keyword">for</span> ; right &lt; <span class="built_in">len</span>(s); right++ &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> index := strings.IndexByte(s1, s[right]); index != <span class="number">-1</span> &#123;</span><br><span class="line">left += index + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">s1 = s[left : right+<span class="number">1</span>]</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s1) &gt; Length &#123;</span><br><span class="line">Length = <span class="built_in">len</span>(s1)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.lxmcloud.cn/images/blog/leetcode/lc3_1.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;3-无重复字符的最长子串&quot;&gt;&lt;a href=&quot;#3-无重复字符的最长子串&quot; class=&quot;headerlink&quot; title=&quot;3. 无重复字符的最长子串&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest
      
    
    </summary>
    
    
      <category term="力扣" scheme="http://yoursite.com/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="力扣" scheme="http://yoursite.com/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>力扣-167</title>
    <link href="http://yoursite.com/2020/03/08/%E5%8A%9B%E6%89%A3-167/"/>
    <id>http://yoursite.com/2020/03/08/%E5%8A%9B%E6%89%A3-167/</id>
    <published>2020-03-08T02:56:47.000Z</published>
    <updated>2020-03-15T02:52:24.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">167. 两数之和 II - 输入有序数组</a></h4><p>难度简单251收藏分享切换为英文关注反馈</p><p>给定一个已按照<strong><em>升序排列\</em></strong> 的有序数组，找到两个数使得它们相加之和等于目标数。</p><p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2<em>。</em></p><p><strong>说明:</strong></p><ul><li>返回的下标值（index1 和 index2）不是从零开始的。</li><li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li></ul><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: numbers &#x3D; [2, 7, 11, 15], target &#x3D; 9</span><br><span class="line">输出: [1,2]</span><br><span class="line">解释: 2 与 7 之和等于目标数 9 。因此 index1 &#x3D; 1, index2 &#x3D; 2 。</span><br></pre></td></tr></table></figure><p>分析：使用双指针</p><p>我们可以用两个指针来确定两个数的下标，两个指针分别从0和len(nums)-1开始</p><p>因为数组是升序所以我们不用考虑排序问题，我们只要判断两个指针所指下标的元素之和是否等于目标值即可</p><p>假设两数之和大于目标值那么肯定是要缩小两数之和，因此我们让第二个指针向前移动就可以了，如果此时移动后和小于目标值，那么移动第一个指针向后。</p><p>为什么我们确认这样可以求出解呢，因为如果此时两数之和大于目标值，那么第二个指针后面的数与第一个指针所指的数之和肯定是大于目标值的，因为数组为升序，同理，和小于目标值，第一个指针之前的数也小于目标值，那么只要在两指针相遇前有解，那么题目就有解。</p><p>时间复杂度O(n)</p><p>空间复杂度O(1)</p><p>代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>; i &lt; j; &#123;</span><br><span class="line"><span class="keyword">if</span> nums[i]+nums[j] &gt; target &#123;</span><br><span class="line">j--</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[i]+nums[j] &lt; target &#123;</span><br><span class="line">i++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">result := []<span class="keyword">int</span>&#123;i + <span class="number">1</span>, j + <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://www.lxmcloud.cn/images/blog/leetcode/lc167.jpg" alt=""></p><p>完整代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> nums = []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>&#125;</span><br><span class="line"><span class="comment">//nums := []int&#123;2, 7, 11, 15&#125;</span></span><br><span class="line">target := <span class="number">9</span></span><br><span class="line">fmt.Println(twoSum(nums, target))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>; i &lt; j; &#123;</span><br><span class="line"><span class="keyword">if</span> nums[i]+nums[j] &gt; target &#123;</span><br><span class="line">j--</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[i]+nums[j] &lt; target &#123;</span><br><span class="line">i++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">result := []<span class="keyword">int</span>&#123;i + <span class="number">1</span>, j + <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;167-两数之和-II-输入有序数组&quot;&gt;&lt;a href=&quot;#167-两数之和-II-输入有序数组&quot; class=&quot;headerlink&quot; title=&quot;167. 两数之和 II - 输入有序数组&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.
      
    
    </summary>
    
    
      <category term="力扣" scheme="http://yoursite.com/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="力扣" scheme="http://yoursite.com/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>力扣-1</title>
    <link href="http://yoursite.com/2020/03/08/%E5%8A%9B%E6%89%A3-1/"/>
    <id>http://yoursite.com/2020/03/08/%E5%8A%9B%E6%89%A3-1/</id>
    <published>2020-03-08T02:28:08.000Z</published>
    <updated>2020-03-15T02:52:30.784Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">1. 两数之和</a></h4><p>难度简单</p><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure><p>分析：使用哈希表</p><p>因为题目要求找到两个整数且他们的和为目标值，因此我们可以让目标值都与每一个数相减，将差放入hasmap中，通过一次遍历，只要能够在hasmap里找到当前的数，那么当前的数和hasmap所对应的数就是我们要找的答案。\</p><p>时间复杂度为：<em>O</em>(<em>n</em>)</p><p>空间复杂度为：<em>O</em>(<em>n</em>)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">maps := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">result := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> index, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">_, isTrue := maps[target-num]</span><br><span class="line"><span class="keyword">if</span> isTrue &#123;</span><br><span class="line">result = <span class="built_in">append</span>(result, maps[target-num])</span><br><span class="line">result = <span class="built_in">append</span>(result, index)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">maps[num] = index</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<img src="https://www.lxmcloud.cn/images/blog/leetcode/lc1.jpg" alt=""></p><p>完整代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> nums = []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>&#125;</span><br><span class="line"><span class="comment">//nums := []int&#123;2, 7, 11, 15&#125;</span></span><br><span class="line">target := <span class="number">9</span></span><br><span class="line">fmt.Println(twoSum(nums, target))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">maps := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">result := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> index, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">_, isTrue := maps[target-num]</span><br><span class="line"><span class="keyword">if</span> isTrue &#123;</span><br><span class="line">result = <span class="built_in">append</span>(result, maps[target-num])</span><br><span class="line">result = <span class="built_in">append</span>(result, index)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">maps[num] = index</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-两数之和&quot;&gt;&lt;a href=&quot;#1-两数之和&quot; class=&quot;headerlink&quot; title=&quot;1. 两数之和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/two-sum/&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
    
      <category term="力扣" scheme="http://yoursite.com/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="力扣" scheme="http://yoursite.com/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>博客自定义主题next</title>
    <link href="http://yoursite.com/2020/02/23/%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%BB%E9%A2%98next/"/>
    <id>http://yoursite.com/2020/02/23/%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%BB%E9%A2%98next/</id>
    <published>2020-02-23T06:33:38.000Z</published>
    <updated>2020-02-25T12:57:21.493Z</updated>
    
    <content type="html"><![CDATA[<h3 id="头像设置"><a href="#头像设置" class="headerlink" title="头像设置"></a>头像设置</h3><p>打开主题里 _config.yml文件找到avarar，后面填入头像的链接</p><p><img src="https://www.lxmcloud.cn/images/blog/boke/avatar2.jpg" alt=""></p><p>成品：</p><p><img src="https://www.lxmcloud.cn/images/blog/boke/avatar3.jpg" alt=""></p><p>接下来将它变成圆形且可以旋转，我们找到next\source\css_common\components\sidebar\sidebar-author.styl文件</p><p><img src="https://www.lxmcloud.cn/images/blog/boke/avator4.jpg" alt=""></p><p>修改成：</p><p><img src="https://www.lxmcloud.cn/images/blog/boke/avatar5.jpg" alt=""></p><h3 id="设置动态背景"><a href="#设置动态背景" class="headerlink" title="设置动态背景"></a>设置动态背景</h3><p>编辑 <strong>主题配置文件</strong>， 搜索 <code>canvas_nest</code> 或 <code>three_waves</code>，根据您的需求设置值为 <code>true</code> 或者 <code>false</code> 即可：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># canvas_nest</span></span><br><span class="line"><span class="attr">canvas_nest:</span> <span class="literal">true</span> <span class="string">//开启动画</span></span><br><span class="line"><span class="attr">canvas_nest:</span> <span class="literal">false</span> <span class="string">//关闭动画</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># three_waves</span></span><br><span class="line"><span class="attr">three_waves:</span> <span class="literal">true</span> <span class="string">//开启动画</span></span><br><span class="line"><span class="attr">three_waves:</span> <span class="literal">false</span> <span class="string">//关闭动画</span></span><br></pre></td></tr></table></figure><h3 id="设置RSS"><a href="#设置RSS" class="headerlink" title="设置RSS"></a>设置RSS</h3><p>在hexo的根目录下执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure><p>在根目录下的/theme/next/_config.yml文件中添加配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feed:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">rss2</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">rss2.xml</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">5</span></span><br><span class="line">    <span class="attr">hub:</span></span><br><span class="line">    <span class="attr">content:</span> <span class="string">'true'</span></span><br></pre></td></tr></table></figure><h3 id="设置访问量观看"><a href="#设置访问量观看" class="headerlink" title="设置访问量观看"></a>设置访问量观看</h3><p>在根目录下的/theme/next/_config.yml文件中修改配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="comment"># count values only if the other configs are false</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># custom uv span for the whole site</span></span><br><span class="line">  <span class="attr">site_uv:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">site_uv_header:</span> <span class="string">&lt;i</span> <span class="string">class="fa</span> <span class="string">fa-user"&gt;&lt;/i&gt;访问人数</span></span><br><span class="line">  <span class="attr">site_uv_footer:</span></span><br><span class="line">  <span class="comment"># custom pv span for the whole site</span></span><br><span class="line">  <span class="attr">site_pv:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">site_pv_header:</span> <span class="string">&lt;i</span> <span class="string">class="fa</span> <span class="string">fa-eye"&gt;&lt;/i&gt;总访问量</span></span><br><span class="line">  <span class="attr">site_pv_footer:</span> <span class="string">次</span></span><br><span class="line">  <span class="comment"># custom pv span for one page only</span></span><br><span class="line">  <span class="attr">page_pv:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">page_pv_header:</span> <span class="string">&lt;i</span> <span class="string">class="fa</span> <span class="string">fa-file-o"&gt;&lt;/i&gt;浏览</span></span><br><span class="line">  <span class="attr">page_pv_footer:</span> <span class="string">次</span></span><br></pre></td></tr></table></figure><p><img src="https://www.lxmcloud.cn/images/blog/boke/num.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;头像设置&quot;&gt;&lt;a href=&quot;#头像设置&quot; class=&quot;headerlink&quot; title=&quot;头像设置&quot;&gt;&lt;/a&gt;头像设置&lt;/h3&gt;&lt;p&gt;打开主题里 _config.yml文件找到avarar，后面填入头像的链接&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https:/
      
    
    </summary>
    
    
      <category term="博客" scheme="http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>我的博客如何建立(二)</title>
    <link href="http://yoursite.com/2020/02/23/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B2/"/>
    <id>http://yoursite.com/2020/02/23/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B2/</id>
    <published>2020-02-23T02:24:23.000Z</published>
    <updated>2020-02-25T12:57:23.859Z</updated>
    
    <content type="html"><![CDATA[<p>需要条件：hexo    （github账号）</p><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>在自己电脑G盘（每个人的各不相同）目录下新建文件夹 blog，按住点击鼠标右键git bash here（或者前敲入：$ mkdir blog ，后$ cd blog）</p><p><img src="https://pic4.zhimg.com/80/v2-47b743555911a9fbb43aa2313f9183db_hd.jpg" alt=""></p><p>然后敲入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install -g hexo-cli</span></span><br></pre></td></tr></table></figure><p>国内可能会出问题或者速度过慢，我们就可以采用cnpm下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install -g cnpm --registry=https://registry.npm.taobao.org</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cnpm install hexo-cli -g</span></span><br></pre></td></tr></table></figure><p>安装成功后：敲入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo -v</span></span><br></pre></td></tr></table></figure><p><img src="https://www.lxmcloud.cn/images/blog/boke/hexo-v.jpg" alt=""></p><p>初始化hexo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo init</span></span><br></pre></td></tr></table></figure><p>启动hexo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">hexo s</span></span><br></pre></td></tr></table></figure><p><img src="https://www.lxmcloud.cn/images/blog/boke/hexo-s.jpg" alt=""></p><p>在浏览器输入       localhost:4000</p><p><img src="https://www.lxmcloud.cn/images/blog/boke/hexochushiye.jpg" alt=""></p><p>这样子博客就初步完成了</p><h3 id="部署到github上"><a href="#部署到github上" class="headerlink" title="部署到github上"></a>部署到github上</h3><p>首先我们需要有一个自己的github账号</p><p><img src="https://www.lxmcloud.cn/images/blog/boke/github-repostiories2.jpg" alt=""></p><p>注意Repository name应填写username.github.io比如我的便是xiaomolin.github.io</p><p>但是因为我已经创建过了所以这里会出现红字</p><p><img src="https://www.lxmcloud.cn/images/blog/boke/chuangjian.jpg" alt=""></p><p>然后点击Create repository</p><h4 id="配置SSH"><a href="#配置SSH" class="headerlink" title="配置SSH"></a>配置SSH</h4><h5 id="设置Git的user-name和email"><a href="#设置Git的user-name和email" class="headerlink" title="设置Git的user name和email"></a>设置Git的user name和email</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.name <span class="string">"github用户名"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.email <span class="string">"注册GitHub的邮箱"</span></span></span><br></pre></td></tr></table></figure><h5 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h5><p>首先要检查自己电脑上是否现有的 SSH key：</p><p><img src="https://pic1.zhimg.com/80/v2-c5428344556ebfe25fee325c7daa5548_hd.jpg" alt=""></p><p>说明这是第一次使用git，接下来生成ssh key</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa -C <span class="string">"邮箱"</span></span></span><br></pre></td></tr></table></figure><p>然后按三下回车，此处使用知乎阿fa的流程</p><p><img src="https://pic2.zhimg.com/80/v2-26799795ac0552d06a81586a130b25ad_hd.jpg" alt=""></p><p><img src="https://pic4.zhimg.com/80/v2-2cb74afa9b7c9077b33da54d4513523b_hd.jpg" alt=""></p><p>在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。</p><p><img src="https://pic3.zhimg.com/80/v2-62eb6df0af0894ffd2344193732065d6_hd.jpg" alt=""></p><p>此时，在用户文件夹（如：C:\Users\阿发）下就会有一个新的文件夹.ssh，里面有刚刚创建的ssh密钥文件id_rsa和id_rsa.pub</p><p><img src="https://www.lxmcloud.cn/images/blog/boke/ssh.jpg" alt=""></p><h5 id="登陆Github-添加-ssh"><a href="#登陆Github-添加-ssh" class="headerlink" title="登陆Github, 添加 ssh"></a>登陆Github, 添加 ssh</h5><p><img src="https://www.lxmcloud.cn/images/blog/boke/setting.jpg" alt=""></p><p>点击用户头像，然后点击显示的Settings(设置)选项；在用户设置栏，点击SSH and GPG keys选项，然后点击New SSH key(新建SSH)按钮；可以使用notepad++打开id_rsa.pub并将其中中的内容复制到Key文本框中，然后点击Add SSH key(添加SSH)按钮；</p><p><img src="https://www.lxmcloud.cn/images/blog/boke/ss.jpg" alt=""></p><p>测试git是否与github连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure><p><img src="https://pic2.zhimg.com/80/v2-1f241d42e10507b2f928acf99686c139_hd.jpg" alt=""></p><p>后敲入:yes</p><h2 id="发布到github"><a href="#发布到github" class="headerlink" title="发布到github"></a><strong>发布到github</strong></h2><p>在blog文件夹中使用Notepad++打开_config.yml，溜到最后…….</p><p><img src="https://pic1.zhimg.com/80/v2-f8ad78fa508b36173f419319512c6fe0_hd.jpg" alt=""></p><p>修改成：</p><p><img src="https://www.lxmcloud.cn/images/blog/boke/deploy.jpg" alt=""></p><p>reop的链接为：</p><p><img src="https://www.lxmcloud.cn/images/blog/boke/lj.jpg" alt=""></p><h5 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">hexo n <span class="string">"文章名字"</span></span></span><br></pre></td></tr></table></figure><p><img src="https://pic2.zhimg.com/80/v2-1c576239e180ec2882160b8f910bc5bd_hd.jpg" alt=""></p><p>清除缓存</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">hexo clean</span></span><br></pre></td></tr></table></figure><p><img src="https://www.lxmcloud.cn/images/blog/boke/clean.jpg" alt=""></p><p>hexo generate(hexo g生成，每次修改本地文件后，需要才能保存)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">hexo g</span></span><br></pre></td></tr></table></figure><p><img src="https://www.lxmcloud.cn/images/blog/boke/hg.jpg" alt=""></p><p>要部署到github上还需安装一个插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">npm install hexo-deployer-git --save</span></span><br></pre></td></tr></table></figure><p>然后部署</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">hexo d</span></span><br></pre></td></tr></table></figure><p>打开自己网址，进行验证是否成功</p><p>到此为止博客基本搭建完成</p><p>参考：<a href="https://zhuanlan.zhihu.com/p/38122668" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/38122668</a></p><p>​            <a href="https://segmentfault.com/a/1190000002645623" target="_blank" rel="noopener">https://segmentfault.com/a/1190000002645623</a></p><p>​            <a href="https://www.bilibili.com/video/av44544186?from=search&amp;seid=8632079203797410486" target="_blank" rel="noopener">https://www.bilibili.com/video/av44544186?from=search&amp;seid=8632079203797410486</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;需要条件：hexo    （github账号）&lt;/p&gt;
&lt;h3 id=&quot;安装hexo&quot;&gt;&lt;a href=&quot;#安装hexo&quot; class=&quot;headerlink&quot; title=&quot;安装hexo&quot;&gt;&lt;/a&gt;安装hexo&lt;/h3&gt;&lt;p&gt;在自己电脑G盘（每个人的各不相同）目录下新建文
      
    
    </summary>
    
    
      <category term="博客" scheme="http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>tensorflow2.0 用卷积层报错</title>
    <link href="http://yoursite.com/2020/02/17/tensorflow2-0-%E7%94%A8%E5%8D%B7%E7%A7%AF%E5%B1%82%E6%8A%A5%E9%94%99/"/>
    <id>http://yoursite.com/2020/02/17/tensorflow2-0-%E7%94%A8%E5%8D%B7%E7%A7%AF%E5%B1%82%E6%8A%A5%E9%94%99/</id>
    <published>2020-02-17T08:29:46.000Z</published>
    <updated>2020-02-17T08:39:48.928Z</updated>
    
    <content type="html"><![CDATA[<h1 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UnknownError: Failed to get convolution algorithm. This <span class="keyword">is</span> probably because cuDNN </span><br><span class="line">failed to initialize, so <span class="keyword">try</span> looking to see <span class="keyword">if</span> a warning log message was printed above. [Op:Conv2D]</span><br></pre></td></tr></table></figure><p>尝试解决办法：</p><p>安装可行版本的CUDA和cuDNN，发现问题仍未解决。</p><p>怀疑有可能是显存不足，打开nvidia msi 查看，发现tensorflow一下子把显存占完了，导致后面用卷积层时无法初始化cuDNN</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>我们只要把tf设置为按需申请显存就行了．</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.compat.v1 <span class="keyword">import</span> ConfigProto</span><br><span class="line"><span class="keyword">from</span> tensorflow.compat.v1 <span class="keyword">import</span> InteractiveSession</span><br><span class="line">config = ConfigProto()</span><br><span class="line">config.gpu_options.allow_growth = <span class="literal">True</span></span><br><span class="line">session = InteractiveSession(config=config)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;报错信息&quot;&gt;&lt;a href=&quot;#报错信息&quot; class=&quot;headerlink&quot; title=&quot;报错信息&quot;&gt;&lt;/a&gt;报错信息&lt;/h1&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;p
      
    
    </summary>
    
    
      <category term="tensorflow" scheme="http://yoursite.com/categories/tensorflow/"/>
    
    
      <category term="tensorflow" scheme="http://yoursite.com/tags/tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>tensorflow API学习(一)</title>
    <link href="http://yoursite.com/2020/02/17/tf%E7%9A%84api/"/>
    <id>http://yoursite.com/2020/02/17/tf%E7%9A%84api/</id>
    <published>2020-02-17T07:52:31.000Z</published>
    <updated>2020-02-19T12:13:17.004Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>Tensorflow是基于图（Graph）的计算系统。而图的节点则是由操作（Operation）来构成的，而图的各个节点之间则是由张量（Tensor）作为边来连接在一起的。所以Tensorflow的计算过程就是一个Tensor流图。Tensorflow的图则是必须在一个Session中来计算。</p><p><a href="http://www.tensorfly.cn/tfdoc/api_docs/python/client.html" target="_blank" rel="noopener">Session</a>提供了Operation执行和Tensor求值的环境</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment"># Build a graph.</span></span><br><span class="line">a = tf.constant([<span class="number">1.0</span>, <span class="number">2.0</span>])</span><br><span class="line">b = tf.constant([<span class="number">3.0</span>, <span class="number">4.0</span>])</span><br><span class="line">c = a * b</span><br><span class="line"></span><br><span class="line"><span class="comment"># Launch the graph in a session.</span></span><br><span class="line">sess = tf.compat.v1.Session()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Evaluate the tensor 'c'.</span></span><br><span class="line"><span class="keyword">print</span> sess.run(c)</span><br><span class="line">sess.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># result: [3., 8.]</span></span><br></pre></td></tr></table></figure><p>一个Session可能会拥有一些资源，例如Variable或者Queue。当我们不再需要该session的时候，需要将这些资源进行释放。有两种方式，</p><ul><li>调用session.close()方法；</li><li>使用with tf.Session()创建上下文（Context）来执行，当上下文退出时自动释放。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Using the `close()` method.  方法一</span></span><br><span class="line">sess = tf.Session()</span><br><span class="line">sess.run(...)</span><br><span class="line">sess.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Using the context manager.  方法二</span></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">  sess.run(...)</span><br></pre></td></tr></table></figure><p>Session类的构造函数如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tf.compat.v1.Session.__init__(target=<span class="string">''</span>, graph=<span class="literal">None</span>, config=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>如果<code>graph</code>在构造会话时未指定任何参数，则默认图形将在会话中启动。如果您<a href="https://www.tensorflow.org/api_docs/python/tf/Graph" target="_blank" rel="noopener"><code>tf.Graph()</code></a>在同一过程中使用一个以上的图（使用创建的图），则每个图必须使用不同的会话，但是每个图可以在多个会话中使用。在这种情况下，将要显式启动的图传递给会话构造函数通常更为清晰。</p><p>执行Operation或者求值Tensor有两种方式：</p><p>如果在创建Session时没有指定Graph，则该Session会加载默认Graph。如果在一个进程中创建了多个Graph，则需要创建不同的Session来加载每个Graph，而每个Graph则可以加载在多个Session中进行计算。</p><p>执行Operation或者求值Tensor有两种方式：</p><ul><li><p>调用Session.run()方法： 该方法的定义如下所示，参数fetches便是一个或者多个Operation或者Tensor。</p></li><li><pre><code class="python">tf.Session.run(fetches, feed_dict=<span class="literal">None</span>)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 调用Operation.run()或则Tensor.eval()方法： 这两个方法都接收参数session，用于指定在哪个session中计算。但该参数是可选的，默认为None，此时表示在进程默认session中计算。</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;python</span><br><span class="line">  import tensorflow as tf</span><br><span class="line">  </span><br><span class="line">  # Build a graph.</span><br><span class="line">  a &#x3D; tf.constant([1.0, 2.0])</span><br><span class="line">  b &#x3D; tf.constant([3.0, 4.0])</span><br><span class="line">  c &#x3D; a * b</span><br><span class="line">  </span><br><span class="line">  with tf.Session():</span><br><span class="line">     print c.eval()</span><br></pre></td></tr></table></figure></code></pre></li></ul><p>参考：<a href="https://www.cnblogs.com/lienhua34/p/5998853.html" target="_blank" rel="noopener">https://www.cnblogs.com/lienhua34/p/5998853.html</a></p><p>​            <a href="https://www.tensorflow.org/api_docs/python/tf/compat/v1/Session" target="_blank" rel="noopener">https://www.tensorflow.org/api_docs/python/tf/compat/v1/Session</a></p><h3 id="Variable"><a href="#Variable" class="headerlink" title="Variable"></a>Variable</h3><p>该<code>Variable()</code>构造函数需要为变量，其可以是一个初始值<code>Tensor</code>的任何类型和形状。此初始值定义变量的类型和形状。构造后，变量的类型和形状是固定的。可以使用分配方法之一更改该值。</p><p>常见用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf;  </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np;   </span><br><span class="line">  </span><br><span class="line">a1 = tf.Variable(tf.random_normal(shape=[<span class="number">2</span>,<span class="number">3</span>], mean=<span class="number">0</span>, stddev=<span class="number">1</span>), name=<span class="string">'a1'</span>)</span><br><span class="line">a2 = tf.Variable(tf.constant(<span class="number">1</span>), name=<span class="string">'a2'</span>)</span><br><span class="line">a3 = tf.Variable(tf.ones(shape=[<span class="number">2</span>,<span class="number">3</span>]), name=<span class="string">'a3'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">sess.run(tf.global_variables_initializer())<span class="comment">#初始化</span></span><br><span class="line"><span class="keyword">print</span> sess.run(a1)</span><br><span class="line"><span class="keyword">print</span> sess.run(a2)</span><br><span class="line"><span class="keyword">print</span> sess.run(a3)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[[ <span class="number">0.76599932</span>  <span class="number">0.99722123</span> <span class="number">-0.89361787</span>]</span><br><span class="line"> [ <span class="number">0.19991693</span> <span class="number">-0.16539733</span>  <span class="number">2.16605783</span>]]</span><br><span class="line"><span class="number">1</span></span><br><span class="line">[[ <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>]</span><br><span class="line"> [ <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>]]</span><br></pre></td></tr></table></figure><p>更多用法请参考文档：<a href="https://www.tensorflow.org/api_docs/python/tf/Variable?hl=zh_cn" target="_blank" rel="noopener">https://www.tensorflow.org/api_docs/python/tf/Variable?hl=zh_cn</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Session&quot;&gt;&lt;a href=&quot;#Session&quot; class=&quot;headerlink&quot; title=&quot;Session&quot;&gt;&lt;/a&gt;Session&lt;/h3&gt;&lt;p&gt;Tensorflow是基于图（Graph）的计算系统。而图的节点则是由操作（Operation）来构
      
    
    </summary>
    
    
      <category term="tensorflow" scheme="http://yoursite.com/categories/tensorflow/"/>
    
    
      <category term="tensorflow" scheme="http://yoursite.com/tags/tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>tensorflow学习(一)</title>
    <link href="http://yoursite.com/2020/02/17/tensorflow/"/>
    <id>http://yoursite.com/2020/02/17/tensorflow/</id>
    <published>2020-02-17T07:52:31.000Z</published>
    <updated>2020-02-18T09:43:05.340Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用tensorflow2-0-进行线性拟合"><a href="#使用tensorflow2-0-进行线性拟合" class="headerlink" title="使用tensorflow2.0 进行线性拟合"></a>使用tensorflow2.0 进行线性拟合</h2><p>拟合直线：y=0.1x+0.3，很简单机器学习任务，思路很简单就是初始化Weight，biases，使用损失函数MSE来判断拟合的效果，使用梯度下降进行参数的更新。其实就是一个最小二乘法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.compat.v1 <span class="keyword">import</span> ConfigProto</span><br><span class="line"><span class="keyword">from</span> tensorflow.compat.v1 <span class="keyword">import</span> InteractiveSession</span><br><span class="line">config = ConfigProto()</span><br><span class="line">config.gpu_options.allow_growth = <span class="literal">True</span></span><br><span class="line">session = InteractiveSession(config=config)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow.compat.v1 <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><p>创建数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#create data</span><br><span class="line">x_data &#x3D;np.random.rand(100).astype(np.float32)</span><br><span class="line">y_data &#x3D;x_data*0.1+0.3</span><br></pre></td></tr></table></figure><p>创建训练模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># create tensorflow structure</span></span><br><span class="line">Weights = tf.Variable(tf.random.uniform((<span class="number">1</span>,), <span class="number">-1.0</span>, <span class="number">1.0</span>))</span><br><span class="line">biases = tf.Variable(tf.zeros((<span class="number">1</span>,)))</span><br><span class="line"></span><br><span class="line">loss = <span class="keyword">lambda</span>: tf.keras.losses.MSE(y_data, Weights * x_data + biases)  </span><br><span class="line"><span class="comment"># alias: tf.losses.mse</span></span><br><span class="line">optimizer = tf.keras.optimizers.SGD(learning_rate=<span class="number">0.5</span>)  </span><br><span class="line"><span class="comment"># alias: tf.optimizers.SGD</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> step <span class="keyword">in</span> range(<span class="number">201</span>):</span><br><span class="line">    optimizer.minimize(loss, var_list=[Weights, biases])</span><br><span class="line">    <span class="keyword">if</span> step % <span class="number">20</span> == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">"&#123;&#125; step, weights = &#123;&#125;, biases = &#123;&#125;"</span>.format(step, Weights.read_value(), biases.read_value()))  <span class="comment"># read_value函数可用numpy替换</span></span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0 step, weights &#x3D; [-0.07186383], biases &#x3D; [0.53049165]</span><br><span class="line">20 step, weights &#x3D; [0.04541961], biases &#x3D; [0.32863754]</span><br><span class="line">40 step, weights &#x3D; [0.08702482], biases &#x3D; [0.3068079]</span><br><span class="line">60 step, weights &#x3D; [0.09691547], biases &#x3D; [0.30161843]</span><br><span class="line">80 step, weights &#x3D; [0.09926673], biases &#x3D; [0.30038476]</span><br><span class="line">100 step, weights &#x3D; [0.0998257], biases &#x3D; [0.30009148]</span><br><span class="line">120 step, weights &#x3D; [0.09995857], biases &#x3D; [0.30002174]</span><br><span class="line">140 step, weights &#x3D; [0.09999017], biases &#x3D; [0.30000517]</span><br><span class="line">160 step, weights &#x3D; [0.09999766], biases &#x3D; [0.30000123]</span><br><span class="line">180 step, weights &#x3D; [0.09999946], biases &#x3D; [0.3000003]</span><br><span class="line">200 step, weights &#x3D; [0.09999989], biases &#x3D; [0.30000007]</span><br></pre></td></tr></table></figure><p>最终预测出的答案和正确答案很接近</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用tensorflow2-0-进行线性拟合&quot;&gt;&lt;a href=&quot;#使用tensorflow2-0-进行线性拟合&quot; class=&quot;headerlink&quot; title=&quot;使用tensorflow2.0 进行线性拟合&quot;&gt;&lt;/a&gt;使用tensorflow2.0 进行线性
      
    
    </summary>
    
    
      <category term="tensorflow" scheme="http://yoursite.com/categories/tensorflow/"/>
    
    
      <category term="tensorflow" scheme="http://yoursite.com/tags/tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>我的博客如何建立(一)</title>
    <link href="http://yoursite.com/2020/02/13/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B1/"/>
    <id>http://yoursite.com/2020/02/13/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B1/</id>
    <published>2020-02-13T06:58:30.122Z</published>
    <updated>2020-03-08T04:01:08.653Z</updated>
    
    <content type="html"><![CDATA[<p>你需要准备好以下软件：</p><ul><li>Node.js环境</li><li>Git</li></ul><p><a href="[[https://lxmcloud.cn/2020/02/23/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B2/](https://lxmcloud.cn/2020/02/23/我的博客如何建立2/)">我的博客如何建立二</a></p><h2 id="Nodejs"><a href="#Nodejs" class="headerlink" title="Nodejs"></a>Nodejs</h2><h3 id="下载nodejs"><a href="#下载nodejs" class="headerlink" title="下载nodejs"></a>下载nodejs</h3><p>官方连接 <a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">https://nodejs.org/zh-cn/</a></p><p>点击左边的版本下载</p><p><img src="https://img-blog.csdnimg.cn/20181121113436911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JteV8xMjM0,size_16,color_FFFFFF,t_70" alt="avatar"></p><h3 id="安装Nodejs"><a href="#安装Nodejs" class="headerlink" title="安装Nodejs"></a>安装Nodejs</h3><p><img src="https://melvinchng.github.io/jekyll/81.png" alt="avatar"></p><p>保持默认设置即可，一路Next，安装很快就结束了。 然后我们检查一下是不是要求的组件都安装好了，同时按下<code>Win</code>和<code>R</code>，打开运行窗口</p><p>在新打开的窗口中输入<code>cmd</code>，敲击回车，打开命令行界面。 在打开的命令行界面中，输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>如果结果如下图所示，则说明安装正确，可以进行下一步了，如果不正确，则需要回头检查自己的安装过程。</p><p><img src="https://xuanwo.io/imgs/opinion/nodejs-test.png" alt=""></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h3 id="下载Git"><a href="#下载Git" class="headerlink" title="下载Git"></a>下载Git</h3><p>官方连接<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a></p><p><img src="https://stormsha.com/media/upload/20191114181049.png" alt=""></p><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p><img src="https://img.shangyexinzhi.com/xztest-image/article/2bb64d6361068e4a92c1f66e16b62c9e.png" alt=""></p><p>后面一路默认next即可</p><p><a href="[[https://lxmcloud.cn/2020/02/23/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B2/](https://lxmcloud.cn/2020/02/23/我的博客如何建立2/)">我的博客如何建立二</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;你需要准备好以下软件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Node.js环境&lt;/li&gt;
&lt;li&gt;Git&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;[[https://lxmcloud.cn/2020/02/23/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE
      
    
    </summary>
    
    
      <category term="博客" scheme="http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
